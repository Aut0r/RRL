{ ======================================================================= ]
[                            POMS Essence Miner                           ]
[                                                                         ]
[           Author       : Timer/IceFire                                  ]
[           Description  : Essence Miner for RS2.                         ]
[           Group Home   : https://github.com/Timer/RRL                   ]
[                                                                         ]
[        More scripts can be found at https://github.com/Timer/RRL        ]
[                                                                         ]
[ ======================================================================= ]
[                              Instructions                               ]
[ ======================================================================= ]
[ 1. Make sure that you have read the read me file.                       ]
[ 2. Use the latest SRL Dev, POMS, and SCAR repositories.                 ]
[ 3. Be in the correct bank near a slot.                                  ]
[ 4. Pouches and pickaxe (if not equipped) in first inventory spaces.     ]
[ 5. Set up lines 61 - 80.                                                ]
[ 6. Press run, always allow to connect to internet and files.            ]
[ 7. Move the mouse over anything you don't understand in the form.       ]
[                                                                         ]
[ ======================================================================= ]
[                               Change log                                ]
[ ======================================================================= ]
[  _2/16/2011_ Revision 1 ______________________________________________  ]
[  | Initial release supporting working essence mining.                 | ]
[                                                                         ]
[ ======================================================================= ]
[                                 Credits                                 ]
[ ======================================================================= ]
[  POMS is  Bobarkinator,  Bumblebee, Camo Developer,  Cut em2 it,  Dub,  ]
[  Home, IceFire908,  jimmy_mac,   J_Pizzle,   mixster,   MylesMadness,   ]
[  NaumanAkhlaQ, Quickmarch, r!ch!e, RAM, Sandstorm, The Man, Tniffoc,    ]
[  YoHoJo, Zyt3x, [-jesus-], Timer.                                       ]
[                                                                         ]
[  Thanks to Freddy1990, Dylock, & Kaitnieks for making SCAR.             ]
[  Thanks to SRL for making an decent libary.                             ]
[  Thanks to Yakman for some of the player form components.               ]
[  Thanks to SKy Scripter for the anti-combo box typing.                  ]
[                                                                         ]
[                 Copyright ©2011 RRL. All rights reserved.               ]
[                                                                         ]
[=========================================================================}

program EssenceMiner;

{$DEFINE SMART} // <-- COMMENT OR REMOVE THIS LINE TO DISABLE SMART!
{$DEFINE REFLECTION} // <-- COMMENT OR REMOVE THIS LINE TO DISABLE USE OF REFLECTION.
{.include SRL\SRL.scar}
{$IFDEF REFLECTION}
{.include RRL\RRL.txt}
{$ENDIF}
{$DEFINE LIMIT_TEXT}
{$IFNDEF Simba}
{.include RRL/scripts/tools/Debug.txt} // <-- Comment this line to DISABLE Debug
{$ENDIF}

{*******************************************************************************
                                  CONSTANTS
*******************************************************************************}

const
  AntiBanChance       = 6;        // Larger the less likely it is for Anti-Ban to occur.
  BreakFor            = 10;       // Minutes you want to break for.
  TakeBreaksEvery     = 25;       // Takes breaks every X amount of loads.
  TakeBreaks          = False;    // Takes regular breaks.
  PlayRandomSound     = True;     // Plays sound when a random is found.
  CMouseSpeed         = 25;       // Your custom mouse speed. The default is 25.
  UseFasterReflectionWalking = True; //(*ONLY IF REFLECTION IS ENABLED*)Walks with reflection faster (speeds up mouse, if you're cautious about mouse speed, change this to false.)
                                     //Default is True.

function BoxReward: TStringArray;
begin
  Result := ['XP', 'oins'];               // Box rewards
end;

{*******************************************************************************
                               GLOBAL VARIABLES
*******************************************************************************}

{*******************************************************************************
  Form variables
*******************************************************************************}

var
  ComboBoxes: array[0..1] of TComboBox;
  CheckBoxes: array[0..4] of TCheckBox;
  Buttons: array[0..4] of TButton;
  Labels: array[0..13] of TLabel;
  Edits: array[0..5] of TEdit;
  BackgroundPicture: LongInt;
  CharsFileString: string;
  StartScript: Boolean;
  Form: TForm;

{*******************************************************************************
  Numbers
*******************************************************************************}

var
  TotalScript, Total: array[0..6] of LongInt;
  EssenceBeingCarried: {$IFDEF Simba}Integer;{$ELSE}Byte;{$ENDIF}
  TimeStarted: LongInt;

{*******************************************************************************
  Booleans
*******************************************************************************}

var
  CurrentlyMemberWorld: Boolean;
  UseReflection: Boolean;

{*******************************************************************************
  Strings
*******************************************************************************}

var
  ScriptSettingsPath: String;
  PlayerSettingsPath: String;
  GenerateProg: string;

{*******************************************************************************
                                    FORMS
*******************************************************************************}

{*******************************************************************************
procedure LoadBackground(Sender: TObject);
By: IceFire908, edited by r!ch!e
Description: Copies the background picture on to the form's canvas.
*******************************************************************************}

procedure LoadBackground(Sender: TObject);
var
  w, h: Integer;
begin
  GetBitmapSize(BackgroundPicture, w, h);

  {$IFDEF Simba}
  DrawBitmap(BackgroundPicture, Form.Canvas, 0, 0);
  {$ELSE}
  SafeCopyCanvas(GetBitmapCanvas(BackgroundPicture), Form.Canvas, 0, 0, w, h, 0, 0, w, h);
  {$ENDIF}
end;

{*******************************************************************************
procedure OnKeyPress(Sender: TObject; var Key: Char);
By: SKy Scripter.
Description: Keeps stupid people from typing in the combobox.
*******************************************************************************}

procedure OnKeyPress(Sender: TObject; var Key: Char);
begin
  Key := Chr(VK_CANCEL);
end;

{*******************************************************************************
procedure SavePlayersToFile;
By: Yakman, edited IceFire908.
Description: Saves players to a data file.
*******************************************************************************}

procedure SavePlayersToFile;
var
  I, CharsFile: LongInt;
  N, A: string;
  II: Byte;
begin
  CharsFile := ReWriteFile(PlayerSettingsPath, False);
  for I := 0 to (GetArrayLength(Players) - 1) do
  begin
    N := IntToStr(I) + '=';
    WriteFileString(CharsFile, 'name' + N + Players[I].Name + Chr(13));
    WriteFileString(CharsFile, 'pass' + N + Players[I].Pass + Chr(13));
    WriteFileString(CharsFile, 'nick' + N + Players[I].Nick + Chr(13));
    WriteFileString(CharsFile, 'skill' + N + Players[I].Skill + Chr(13));
    WriteFileString(CharsFile, 'active' + N + BoolToStr(Players[I].Active) + Chr(13));
    for II := 0 to 1 do
    begin
      A := 's[' + IntToStr(II) + ']' + N;
      WriteFileString(CharsFile, 'string' + A + Players[I].Strings[II] + Chr(13));
      WriteFileString(CharsFile, 'integer' + A + IntToStr(Players[I].Integers[II]) + Chr(13));
    end;
    for II := 0 to 3 do
      WriteFileString(CharsFile, 'booleans[' + IntToStr(II) + ']' + N + BoolToStr(Players[I].Booleans[II]) + Chr(13));
  end;
  CloseFile(CharsFile);
end;

{*******************************************************************************
function CountPlayers2: LongInt;
By: Yakman.
Description: Counts the number of players in the Chars File.
*******************************************************************************}

function CountPlayers2: LongInt;
var
  I: LongInt;
begin
  repeat
    if (Pos('pass' + IntToStr(I) + '=', CharsFileString) = 0) then
    begin
      Result := I;
      Break;
    end;
    Inc(I);
  until (False);
end;

{*******************************************************************************
function NextEnter2(SubStr: string): LongInt;
By: Yakman.
Description: ???
*******************************************************************************}

function NextEnter2(SubStr: string): LongInt;
var
  I: LongInt;
begin
  for I := 0 to Length(SubStr) do
    if (Copy(SubStr, I, 1) = Chr(13)) then
    begin
      Result := I;
      Exit;
    end
end;

{*******************************************************************************
function GetFileData2(ArrayIndex: Integer; PlayerOption: string): string;
By: Yakman.
Description: Returns strings from a data file.
*******************************************************************************}

function GetFileData2(ArrayIndex: Integer; PlayerOption: string): string;
var
  TString: string;
begin
  repeat
    Result := '';
    TString := PlayerOption + IntToStr(ArrayIndex) + '=';
    if (Pos(TString, CharsFileString) = 0) then
      Break;
    Result := Copy(CharsFileString, Pos(TString, CharsFileString), NextEnter2(Copy(CharsFileString, Pos(TString, CharsFileString), Length(CharsFileString))) - 1);
    Delete(Result, 1, Length(TString));
  until (True);
end;

{*******************************************************************************
procedure SetUpPlayerArrayLengths(I: LongInt);
By: IceFire908.
Description: Sets up a player's array lengths.
*******************************************************************************}

procedure SetUpPlayerArrayLengths(I: LongInt);
begin
  SetLength(Players[I].Booleans, 5);
  SetLength(Players[I].Integers, 7);
  SetLength(Players[I].Strings, 2);
  Players[I].Loc := 'Not yet started autoing.';
  Players[I].BoxRewards := BoxReward;
end;

{*******************************************************************************
procedure ScriptTerminate;
Description: Fixes Disguise ... Add anything else needed.
When TerminateScript is called, ScriptTerminate is
automatically executed.
*******************************************************************************}

procedure ScriptTerminate;
var
  clientR: Integer;
  prps: string;
begin
  {$IFDEF Simba}
  Disguise('Simba');
  {$ELSE}
  Disguise('SCAR Divi CDE');
  FreeSRL;
  {$ENDIF}
  {if (GenerateProg <> '') then
  begin
    clientR := InitializeHTTPClient(True, True);
    AddPostVariable(clientR, 'report', GenerateProg);
    AddPostVariable(clientR, 'type', 'POMSES');
    AddPostVariable(clientR, 'id', TheDate(Date_Formal) + ' ' + TheTime);
    prps := PostHTTPPageEx(clientR, 'http://timer150.com/POMS.php');
    Writeln(prps);
    FreeHTTPClient(clientR);
  end;
  prps := GetPage('http://timer150.com/stats.php');
  if (Pos('Please enter your Villavu fourm name to continue!', prps) > 0) then
  begin
    Writeln('Please add your Villavu Username to the database.');
    OpenWebPage('http://timer150.com/stats.php');
  end;}
end;

{*******************************************************************************
procedure DWriteLn(_text: string);
By: Timer
Description: Debugs
*******************************************************************************}
procedure DWriteLn(_text: string);
begin
  {$IFDEF POMS_DEBUG}
    if (not DebugKill) then
      POMS_DebugLine(_text);
  {$ENDIF}
end;

{*******************************************************************************
procedure DDebugTPA(TPA: TPointArray);
By: Timer
Description: Debugs TPA
*******************************************************************************}
procedure DDebugTPA(TPA: TPointArray);
begin
  {$IFDEF POMS_DEBUG}
    if (not DebugKill) then
      DebugTPA(TPA);
  {$ENDIF}
end;

{*******************************************************************************
procedure ClearTPA;
By: Timer
Description: Clears Canvas
*******************************************************************************}
procedure ClearTPA;
begin
  {$IFDEF POMS_DEBUG}
    if (not DebugKill) then
      ClearSMARTCanvas;
  {$ENDIF}
end;

{*******************************************************************************
function ToMine: TPointArray;
By: Timer
Description: Path To Mine
*******************************************************************************}
function ToMine: TPointArray;
var
  b: TPointArray;
begin
  {$IFDEF REFLECTION}
  Result := [Point(GetLocation.x, GetLocation.y), Point(3258, 3409), Point(3253, 3401)];
  {$ELSE}
  Result := b;
  {$ENDIF}
end;

{*******************************************************************************
function ToBank: TPointArray;
By: Timer
Description: Path To Bank
*******************************************************************************}
function ToBank: TPointArray;
var
  b: TPointArray;
begin
  {$IFDEF REFLECTION}
  Result := [Point(GetLocation.x, GetLocation.y), Point(3258, 3411), Point(3253, 3420)];
  {$ELSE}
  Result := b;
  {$ENDIF}
end;

{*******************************************************************************
procedure AddPoint(ppp: TPoint; var Arr: TPointArray);
By: Timer
Description: Add point to array.
*******************************************************************************}
procedure AddPoint(ppp: TPoint; var Arr: TPointArray);
begin
  SetLength(Arr, Length(Arr) + 1);
  Arr[High(Arr)] := ppp;
end;

{*******************************************************************************
function GenerateCrapLine(start, endd: TPoint): TPointArray;
By: Timer
Description: Generate a crappy, working, line.
*******************************************************************************}
function GenerateCrapLine(start, endd: TPoint): TPointArray;
begin
  while (Abs(start.x - endd.x) <> 0) or (Abs(start.y - endd.y) <> 0) do
  begin
    if (Abs(start.x - endd.x) <> 0) then
      if (start.x - endd.x > 0) then
        Dec(start.x)
      else
        Inc(start.x);
    if (Abs(start.y - endd.y) <> 0) then
      if (start.y - endd.y > 0) then
        Dec(start.y)
      else
        Inc(start.y);
    AddPoint(Point(start.x, start.y), Result);
  end;
end;

{*******************************************************************************
function GenerateCrapLines(start: TPointArray): TPointArray;
By: Timer
Description: Generate a crappy, working, line.
*******************************************************************************}
function GenerateCrapLines(start: TPointArray): TPointArray;
var
  i: LongInt;
begin
  for i := 0 to High(start) do
    try
      Result := CombineTPA(Result, GenerateCrapLine(start[i], start[i + 1]));
    except
    end;
end;

{*******************************************************************************
function FlagExx(Dist: Integer; Path: TPointArray): Boolean;
By: Timer
Description: Paints and walks.
*******************************************************************************}
function FlagExx(Dist: Integer; Path: TPointArray): Boolean;
var
  Tx, Ty, M, D1, D2: Integer;
begin
  Result := False;
  M := GetSystemTime;
  while (FindColor(Tx, Ty, FlagColor, MMX1, MMY1, MMX2, MMY2)) do
  begin
    wait(50);
    D1 := Distance(Tx, Ty + 14, MMCX, MMCY);
    if (D1 <= Dist) then
    begin
      Result := True;
      Exit;
    end;
    Wait(100);
    if (GetColor(6, 6) <> clWhite) then
      if (GetSystemTime - M > 5000) then
      begin
        if (D1 = D2) then Exit;
        D2 := D1;
        M := GetSystemTime;
      end;
    if (Random(20) = 0) then IdleTime(500, 1000, 0.005);
    if SRL_Procs[SRL_AntiBan] <> nil then
      SRL_Procs[SRL_AntiBan]();
    {$IFDEF POMS_DEBUG}
      if (not DebugKill) then
      begin
        CL := GetMyPos;
        if (LL.x <> CL.x) or (LL.y <> CL.y) then
        begin
          SetLength(Path2, Length(Path));
          for ii := 0 to High(Path) do
          begin
            Path2[ii] := TileToMM(Path[ii]);
            PTT := CombineTPA(PTT,
            [Path2[ii],
            Point(Path2[ii].x - 1, Path2[ii].y),
            Point(Path2[ii].x + 1, Path2[ii].y),
            Point(Path2[ii].x, Path2[ii].y + 1),
            Point(Path2[ii].x, Path2[ii].y - 1),
            Point(Path2[ii].x - 1, Path2[ii].y - 1),
            Point(Path2[ii].x + 1, Path2[ii].y + 1),
            Point(Path2[ii].x + 1, Path2[ii].y - 1),
            Point(Path2[ii].x - 1, Path2[ii].y + 1),
            Point(Path2[ii].x, Path2[ii].y - 2),
            Point(Path2[ii].x, Path2[ii].y + 2),
            Point(Path2[ii].x - 1, Path2[ii].y - 2),
            Point(Path2[ii].x + 1, Path2[ii].y - 2),
            Point(Path2[ii].x - 1, Path2[ii].y + 2),
            Point(Path2[ii].x + 1, Path2[ii].y + 2),
            Point(Path2[ii].x - 2, Path2[ii].y + 2),
            Point(Path2[ii].x + 2, Path2[ii].y + 2),
            Point(Path2[ii].x - 2, Path2[ii].y - 2),
            Point(Path2[ii].x + 2, Path2[ii].y - 2),
            Point(Path2[ii].x - 2, Path2[ii].y),
            Point(Path2[ii].x + 2, Path2[ii].y),
            Point(Path2[ii].x - 2, Path2[ii].y - 1),
            Point(Path2[ii].x - 2, Path2[ii].y + 1),
            Point(Path2[ii].x + 2, Path2[ii].y - 1),
            Point(Path2[ii].x + 2, Path2[ii].y + 1),
            Point(Path2[ii].x - 3, Path2[ii].y - 3),
            Point(Path2[ii].x - 2, Path2[ii].y - 3),
            Point(Path2[ii].x - 1, Path2[ii].y - 3),
            Point(Path2[ii].x + 0, Path2[ii].y - 3),
            Point(Path2[ii].x + 1, Path2[ii].y - 3),
            Point(Path2[ii].x + 2, Path2[ii].y - 3),
            Point(Path2[ii].x + 3, Path2[ii].y - 3),
            Point(Path2[ii].x - 3, Path2[ii].y - 2),
            Point(Path2[ii].x + 3, Path2[ii].y - 2),
            Point(Path2[ii].x - 3, Path2[ii].y - 1),
            Point(Path2[ii].x + 3, Path2[ii].y - 1),
            Point(Path2[ii].x - 3, Path2[ii].y + 0),
            Point(Path2[ii].x + 3, Path2[ii].y + 0),
            Point(Path2[ii].x - 3, Path2[ii].y + 1),
            Point(Path2[ii].x + 3, Path2[ii].y + 1),
            Point(Path2[ii].x - 3, Path2[ii].y + 2),
            Point(Path2[ii].x + 3, Path2[ii].y + 2),
            Point(Path2[ii].x - 3, Path2[ii].y + 3),
            Point(Path2[ii].x - 2, Path2[ii].y + 3),
            Point(Path2[ii].x - 1, Path2[ii].y + 3),
            Point(Path2[ii].x + 0, Path2[ii].y + 3),
            Point(Path2[ii].x + 1, Path2[ii].y + 3),
            Point(Path2[ii].x + 2, Path2[ii].y + 3),
            Point(Path2[ii].x + 3, Path2[ii].y + 3)]);
          end;
          PT := GenerateCrapLines(Path2);
          ClearTPA;
          DDebugTPA(CombineTPA(PT, PTT));
          PTT := [];
          PT := [];
          Path2 := [];
          LL := GetMyPos;
        end;
      end;
    {$ENDIF}
  end;
  Wait(RandomRange(200, 400));
  ClearTPA;
end;

{*******************************************************************************
function WalkOurPath(Path: TPointArray): Boolean;
By: Timer
Description: Walks reflection path.
*******************************************************************************}
function WalkOurPath(Path: TPointArray): Boolean;
var
  i, tMouseT, TH: Integer;
  P: TPoint;
begin
  {$IFDEF REFLECTION}
  Writeln('Walking path [with reflection].');
  TH := High(Path);
  {$IFDEF POMS_DEBUG}
    if (not DebugKill) then
    begin
      SetLength(Path2, Length(Path));
      for ii := 0 to High(Path) do
        Path2[ii] := TileToMM(Path[ii]);
      PT := GenerateCrapLines(Path2);
      ClearTPA;
      DDebugTPA(PT);
    end;
  {$ENDIF}
  for i := 1 to TH do
  begin
    if (not TileOnMinimap(RSTile(Path[i].x, Path[i].y))) then
      Exit;
    P := TileToMinimap(RSTile(Path[i].x, Path[i].y));
    if (UseFasterReflectionWalking) then
    begin
      tMouseT := MouseSpeed;
      MouseSpeed := 45;
      Mouse(P.x, P.y, 8, 8, True);
      MouseSpeed := tMouseT;
    end else
      Mouse(P.x, P.y, 8, 8, True);
    Wait(250);
    FlagExx(0, Path);
    if (not UseFasterReflectionWalking) then
      Wait(1500 + Random(500));
  end;
  Result := True;
  if (UseFasterReflectionWalking) then
    Wait(1500 + Random(500));
  {$ELSE}
  Result := False;
  {$ENDIF}
end;

{*******************************************************************************
procedure RealTimeDebug;
By: Timer
Description: Real time canvas painting.
*******************************************************************************}
procedure RealTimeDebug;
{$IFDEF POMS_DEBUG}
var
  TCounter: Integer;
{$ENDIF}
begin
  {$IFDEF POMS_DEBUG}
    if (not DebugKill) then
    begin
      TCounter := (1 + ((GetSystemTime - TimeStarted) / 1000));
      POMS_VARIABLES := ['Time Running: ' + TimeRunning,
      'Essence Mined: ' + IntToStr(Total[0]),
      'Essence P/H: ' + IntToStr(Round((3600 * (Total[0])) / (TCounter))),
      'Trips Made: ' + IntToStr(Total[2]),
      'Trips P/H: ' + IntToStr(Round((3600 * (Total[2])) / (TCounter))),
      'Mining EXP Gained: ' + FloatToStr(Total[1]),
      'Mining EXP P/H: ' + IntToStr(Round((3600 * (Total[1])) / (TCounter)))];
      ClearSMARTCanvas;
    end;
  {$ENDIF}

  {$IFNDEF Simba}
  SetTimeOut(1000, 'RealTimeDebug');
  {$ENDIF}
end;

{*******************************************************************************
procedure CreateNewSettingsFile;
By: Camo Developer
Description: Checks to see if the PlayerSettingsPath file exists, if it doesn't then
it creates it.
*******************************************************************************}

procedure CreateNewSettingsFile;
var
  F: Integer;
  Pathg: string;
begin
  Pathg := PlayerSettingsPath;
  if (not FileExists(Pathg)) then
  begin
    F := RewriteFile(Pathg, True);
    WriteFileString(F, 'Please do not erase this file! Thank you, -The POMS Staff' + Chr(13) + Chr(10) + Chr(13) + Chr(10));
    CloseFile(F);
  end;
end;

{*******************************************************************************
procedure LoadPlayersFromFile;
By: Yakman, edited by IceFire908.
Description: Loads players from the data file.
*******************************************************************************}

procedure LoadPlayersFromFile;
var
  I, CharsFile, Temp: LongInt;
  S: string;
  II: Byte;
begin
  CreateNewSettingsFile;
  if (not (FileExists(PlayerSettingsPath))) then
  begin
    SavePlayersToFile;
    WriteLn('Please re-run script.');
    TerminateScript;
  end;
  CharsFile := OpenFile(PlayerSettingsPath, False);
  if (CharsFile < 0) then
  begin
    SavePlayersToFile;
    CharsFile := OpenFile(AppPath + '.DAT', False)
    if (CharsFile < 0) then
      Exit;
  end;
  ReadFileString(CharsFile, CharsFileString, FileSize(CharsFile));
  CloseFile(CharsFile);
  Temp := CountPlayers2;
  if (Temp <= 0) then
    Temp := 1;
  SetArrayLength(Players, Temp);
  HowManyPlayers := GetArrayLength(Players);
  for I := 0 to (HowManyPlayers - 1) do
  begin
    SetUpPlayerArrayLengths(I);
    Players[I].Name := GetFileData2(I, 'name');
    Players[I].Pass := GetFileData2(I, 'pass');
    Players[I].Nick := GetFileData2(I, 'nick');
    Players[I].Skill := GetFileData2(I, 'skill');
    Players[I].Active := StrToBoolDef(GetFileData2(I, 'active'), False);
    for II := 0 to 1 do
    begin
      S := 's[' + IntToStr(II) + ']';
      Players[I].Strings[II] := GetFileData2(I, 'string' + S);
      Players[I].Integers[II] := StrToIntDef(GetFileData2(I, 'integer' + S), 0);
    end;
    for II := 0 to 3 do
      Players[I].Booleans[II] := StrToBoolDef(GetFileData2(I, 'booleans[' + IntToStr(II) + ']'), False);
  end;
  CloseFile(CharsFile);
end;

{*******************************************************************************
procedure DeclarePlayersFromForm(I: LongInt);
By: IceFire908.
Description: Declares the settings from the form into the SRL player array.
*******************************************************************************}

procedure DeclarePlayersFromForm(I: LongInt);
var
  II: Byte;
begin
  Players[I].Name := Edits[0].Text;
  Players[I].Pass := Edits[1].Text;
  Players[I].Nick := Edits[2].Text;
  Players[I].Skill := ComboBoxes[1].Text;
  Players[I].Active := CheckBoxes[0].Checked;
  Players[I].Strings := [Edits[3].Text, ComboBoxes[0].Text];
  Players[I].Integers[0] := StrToIntDef(Edits[4].Text, 0);
  Players[I].Integers[1] := StrToIntDef(Edits[5].Text, 0);
  for II := 0 to 3 do
    Players[I].Booleans[II] := CheckBoxes[1 + II].Checked;
end;

{*******************************************************************************
procedure DeclareFormFromPlayers(I: LongInt);
By: IceFire908.
Description: Declares the settings from the SRL player array into the form.
*******************************************************************************}

procedure DeclareFormFromPlayers(I: LongInt);
var
  II: Byte;
begin
  try
    if (Players[I].Name <> '') then
      Edits[0].Text := Players[I].Name
    else
      Edits[0].Text := 'New Username';
    if (Players[I].Pass <> '') then
      Edits[1].Text := Players[I].Pass
    else
      Edits[1].Text := 'New Password';
    if (Players[I].Nick <> '') then
      Edits[2].Text := Players[I].Nick
    else
      Edits[2].Text := 'New Nickname';
    if (Players[I].Skill <> '') then
      ComboBoxes[1].Text := Players[I].Skill
    else
      ComboBoxes[1].Text := 'Agility';
    CheckBoxes[0].Checked := Players[I].Active;
    if (Players[I].Strings[0] <> '') then
      Edits[3].Text := Players[I].Strings[0]
    else
      Edits[3].Text := '0000';
    if (Players[I].Strings[1] <> '') then
      ComboBoxes[0].Text := Players[I].Strings[1]
    else
      ComboBoxes[0].Text := '[Reg] (VEB)';
    Edits[4].Text := IntToStr(Players[I].Integers[0]);
    Edits[5].Text := IntToStr(Players[I].Integers[1]);
    for II := 1 to 4 do
      CheckBoxes[II].Checked := Players[I].Booleans[II - 1];
  except
  end;
end;

{*******************************************************************************
procedure ButtonClick(Sender: TObject);
By: IceFire908.
Description: Actions that happen when buttons are clicked in the form.
*******************************************************************************}

procedure ButtonClick(Sender: TObject);
var
  V: TVariantArray;
begin
  case Sender of
    Buttons[0]: if (Currentplayer <> 0) then
                begin
                  DeclarePlayersFromForm(CurrentPlayer);
                  IncEx(CurrentPlayer, -1);
                  Labels[0].Caption := 'Player # ' + IntToStr(CurrentPlayer) + '.';
                  DeclareFormFromPlayers(CurrentPlayer);
                end;
    Buttons[1]: begin
                  DeclarePlayersFromForm(CurrentPlayer);
                  SetArrayLength(Players, GetArrayLength(Players) + 1);
                  CurrentPlayer := GetArrayLength(Players) - 1;
                  SetUpPlayerArrayLengths(CurrentPlayer);
                  Labels[0].Caption := 'Player # ' + IntToStr(CurrentPlayer) + '.';
                  DeclareFormFromPlayers(CurrentPlayer);
                end;
    Buttons[2]: if (GetArrayLength(Players) > 1) then
                begin
                  SetArrayLength(Players, GetArrayLength(Players) - 1);
                  CurrentPlayer := GetArrayLength(Players) - 1;
                  Labels[0].Caption := 'Player # ' + IntToStr(CurrentPlayer) + '.';
                  DeclareFormFromPlayers(CurrentPlayer);
                end;
    Buttons[3]: begin
                  try
                    Players[CurrentPlayer + 1].Name := Players[CurrentPlayer + 1].Name;
                  except
                    Exit;
                  end;
                  DeclarePlayersFromForm(CurrentPlayer);
                  Inc(CurrentPlayer);
                  Labels[0].Caption := 'Player # ' + IntToStr(CurrentPlayer) + '.';
                  DeclareFormFromPlayers(CurrentPlayer);
                end;
    Buttons[4]: begin
                  SetArrayLength(V, 0);
                  Form.ModalResult := MROK;
                  StartScript := True;
                end;
  end;
end;

{*******************************************************************************
procedure FormClosed(Sender: TObject; var CanClose: Boolean);
By: IceFire908.
Description: Things that need to happen upon closing form.
*******************************************************************************}

procedure FormClosed(Sender: TObject; var CanClose: Boolean);
begin
  DeclarePlayersFromForm(CurrentPlayer);
  SavePlayersToFile;
  HowManyPlayers := GetArrayLength(Players);
  CanClose := True
end;

{*******************************************************************************
procedure InitForm;
By: IceFire908.
Description: Initializes the form.
*******************************************************************************}

procedure InitForm;
var
  FormInfo: TStringArray;
  I, II: Byte;
begin
  LoadPlayersFromFile;
  FormInfo := ['go to the previous player', '<<', 'create a new player', 'Create Player', 'delete a player', 'Delete Player', 'go to the next player', '>>', 'start POMS Essence Miner', 'Start Script', 'player is going to be used', '68', '214', 'you are using a small pouch', '336', '205', 'you are using a medium pouch', '412', '205', 'you are using a large pouch', '336', '225', 'you are using a gaint pouch', '412', '225', 'location to mine at', 'skill to chose in the genie random event', '[Reg] (VEB)', '[Pure] (VEB)', 'Agility', 'Attack', 'Construction', 'Cooking', 'Crafting', 'Defence', 'Farming', 'Firemaking', 'Fishing',
       'Fletching', 'Herblore', 'Hitpoints', 'Hunting', 'Magic', 'Mining', 'Prayer', 'Ranged', 'Runecrafting', 'Slayer', 'Smithing', 'Strength', 'Summoning', 'Thieving', 'Woodcutting', 'Current player # being viewed', '14', '51', 'Player # 0.', 'Check if player is going to be used', '84', '216', 'Player Active.', 'Type in your username here', '13', '90', 'Username:', 'Type in your password here', '216', '90', 'Password:', 'Type in the 2nd, 3rd, and 4th letters of your username here', '15', '120', 'Nickname:', 'Type in your bank pin here', '223', '120', 'Bank Pin:', 'Type in the amount of loads to do per a round here',
       '38', '150', 'Loads:', 'Type in the amount of essence to mine', '217', '150', 'Essences:', 'Select a place to mine at', '19', '180', 'Location:', 'Select a skill to chose in the genie random event', '216', '180', 'Lamp Skill:', 'Check if you are using a small pouch', '352', '207', 'S Pouch.', 'Check if you are using a medium pouch', '428', '207', 'M Pouch.', 'Check if you are using a large pouch', '353', '227', 'L Pouch.', 'Check if you are using a gaint pouch', '428', '227', 'G Pouch.', '83', '88', '283', '88', '83', '118', '283', '118', '83', '148', '283', '148'];
  Form := CreateForm;
  with Form do
  begin
    Caption := 'POMS Essence Miner. Powered by SRL.';
    {$IFDEF Simba}
    SetBounds(162, 102, 487, 243);
    {$ELSE}
    SetBounds(162, 102, 497, 268);
    {$ENDIF}
    BorderStyle := BSToolWindow;
    OnPaint := @LoadBackground;
    OnCloseQuery := @FormClosed;
    ShowHint := True;
  end;
  for I := 0 to 4 do
  begin
    Buttons[I] := TButton.Create(Form);
    with Buttons[I] do
    begin
      Parent := Form;
      Hint := 'Click to ' + FormInfo[2 * I] + '.';
      SetBounds(69 + (88 * I), 61, 85, 19);
      if (I = 4) then
        SetBounds(176, 208, 136, 29);
      Caption := FormInfo[1 + (2 * I)];
      OnClick := @ButtonClick;
    end;
  end;
  for I := 0 to 4 do
  begin
    CheckBoxes[I] := TCheckBox.Create(Form);
    with CheckBoxes[I] do
    begin
      Parent := Form;
      Hint := 'Check if ' + FormInfo[10 + (3 * I)] + '.';
      SetBounds(StrToInt(FormInfo[11 + (3 * I)]), StrToInt(FormInfo[12 + (3 * I)]), 17, 17);
    end;
  end;
  for I := 0 to 1 do
  begin
    ComboBoxes[I] := TComboBox.Create(Form);
    with ComboBoxes[I] do
    begin
      Parent := Form;
      Hint := 'Select a ' + FormInfo[25 + I] + '.';
      SetBounds(83 + (200 * I), 178, 121, 21);
      OnKeyPress := @OnKeyPress;
      for II := 0 to (1 + (22 * I)) do
        Items.Add(FormInfo[27 + (2 * I) + II]);
    end;
  end;
  for I := 0 to 13 do
  begin
    Labels[I] := TLabel.Create(Form);
    with Labels[I] do
    begin
      Parent := Form;
      Font.Color := CLSilver;
      Hint := FormInfo[53 + (4 * I)] + '.';
      SetBounds(StrToInt(FormInfo[54 + (4 * I)]), StrToInt(FormInfo[55 + (4 * I)]), 16, 66);
      Font.Height := -13;
      case I of
        0, 1, 10, 11, 12, 13: Font.Height := -11;
      end;
      Caption := FormInfo[56 + (4 * I)];
    end;
  end;
  for I := 0 to 5 do
  begin
    Edits[I] := TEdit.Create(Form);
    with Edits[I] do
    begin
      Parent := Form;
      Hint := FormInfo[61 + (4 * I)] + '.';
      SetBounds(StrToInt(FormInfo[109 + (2 * I)]), StrToInt(FormInfo[110 + (2 * I)]), 121, 21);
      case I of
        1, 3: PasswordChar := '*';
      end;
    end;
  end;
  DeclareFormFromPlayers(0);
end;

{*******************************************************************************
procedure SafeInitForm;
By: SCAR CDE Manual.
Description: Keeps SCAR stable.
*******************************************************************************}

procedure SafeInitForm;
var
  V: TVariantArray;
begin
  SetArrayLength(V, 0);
  ThreadSafeCall('InitForm', V);
end;

{*******************************************************************************
procedure ShowFormModal;
By: SCAR CDE Manual.
Description: Keeps SCAR stable.
*******************************************************************************}

procedure ShowFormModal;
begin
  Form.ShowModal;
end;

{*******************************************************************************
procedure SafeShowFormModal;
By: SCAR CDE Manual.
Description: Keeps SCAR stable.
*******************************************************************************}

procedure SafeShowFormModal;
var
  V: TVariantArray;
begin
  SetArrayLength(V, 0);
  ThreadSafeCall('ShowFormModal', V);
end;

{*******************************************************************************
procedure StartUpScript;
Description: Does everything to start the script up.
*******************************************************************************}

procedure StartUpScript;
var
  I: Byte;
begin
  ClearDebug;
  Disguise('POMSEM');
  BackgroundPicture := LoadBitmap(ScriptPath + 'resources\BackgroundPOMSEM.bmp');
  Wait(2000);
  for I := 0 to 5 do
    TotalScript[I] := StrToIntDef(ReadINI('TotalScript', IntToStr(I), ScriptSettingsPath), 0);
  WriteLn('__________________      _____    ____________________   _____');
  Wait(100);
  WriteLn('\______   \_____  \    /     \  /   _____/\_   _____/  /     \');
  Wait(100);
  WriteLn(' |     ___//   |   \  /  \ /  \ \_____  \  |    __)_  /  \ /  \');
  Wait(100);
  WriteLn(' |    |   /    |    \/    Y    \/        \ |        \/    Y    \');
  Wait(100);
  WriteLn(' |____|   \_______  /\____|__  /_______  //_______  /\____|__  /');
  Wait(100);
  WriteLn('                  \/         \/        \/         \/         \/');
  Wait(100);
  WriteLn('  ||Total script starts : ' + IntToStr(TotalScript[0]) + '||   ||Total essence mined : ' + IntToStr(TotalScript[1]) + '||');
  Wait(200);
  {$IFDEF POMS_DEBUG}
    if (GetApplication.MessageBox('Use POMS Debug? (Smart Painting, heavy on RAM and CPU)', 'POMS', 4) = 7) then
    begin
      DebugKill := True;
      Writeln('POMS Debug has been shut off.');
    end;
  {$ENDIF}
  WriteLn('To begin, fill out the form, then press start.');
  try
    SafeInitForm;
    SafeShowFormModal;
  except
    WriteLn('Error in form!');
  finally
    FreeForm(Form);
    FreeBitMap(BackgroundPicture);
  end;
  if (not (StartScript)) then
    TerminateScript;
  Smart_Server := 38;
  Smart_Members := False;
  Smart_Signed := True;
  Smart_SuperDetail := False;
  CurrentlyMemberWorld := False;
  SetUpSRL;
  {$IFDEF SIMBA}
  SetScriptProp(SP_OnTerminate,['ScriptTerminate']);
  SetSupressExceptions(true);
  {$ENDIF}
  SymbolAccuracy := 0.7;
  {$IFNDEF SRL_SMART}
    {$IFNDEF SIMBA}
    FindWindowBySize(766, 504);
    Wait(500 + Random(250));
    ActivateClient;
    {$ENDIF}
  {$ENDIF}
  {$IFDEF POMS_DEBUG}
  if (not DebugKill) then
  begin
    SmartSetDebug(True);
    POMS_SCRIPT := 'Essence Miner';
    POMS_VARIABLES := ['Time Running: ' + TimeRunning,
    'Essence Mined: 0',
    'Essence P/H: 0',
    'Trips Made: 0',
    'Trips P/H: 0',
    'Mining EXP Gained: 0',
    'Mining EXP P/H: 0'];
  end;
  {$ENDIF}
  ClearTPA;
  SetArrayLength(RC_Masters, 0);;
  Wait(1000 + Random(1000));
  TimeStarted := GetSystemTime;
  {$IFDEF REFLECTION}
    UseReflection := True;
  {$ELSE}
    UseReflection := False;
  {$ENDIF}
end;

{*******************************************************************************
                             ALL PURPOSE ROUTINES
*******************************************************************************}

{*******************************************************************************
procedure AntiBan(AntiChance: Integer);
By: r!ch!e
Description: Various randomly chosen AntiBan functions
*******************************************************************************}

procedure AntiBan(AntiChance: Integer);
begin
  if (not (LoggedIn)) then
    Exit;
  ClickToContinue;
  UseRewardBox;
  DWriteLn('Antiban!');
  case Random(AntiChance * 100) of
    0..2: begin
               HoverSkill('Mining', False);
               Wait(2053 + Random(432));
             end;
    3..12: PickUpMouse;
    13,14: begin
            MakeCompass('N');
            Wait(200 + Random(60));
            MakeCompass('S');
            Wait(80 + Random(25));
            MakeCompass('N');
          end;
    15: begin
         GameTab(tab_Friends);
         Wait(1000 + Random(500));
         GameTab(tab_Inv);
        end;
    16: RandomMovement;
    17..20: BoredHuman;
    21: begin
         SetAngle(False);
         Wait(30 + Random(10));
         SetAngle(True);
       end;
    22: HoverSkill('random', False);
   23: ExamineInv;
   24..34: MMouse(Random(650), Random(500), 0, 0);
   35: FixChat;
   50..90: IdleTime(1000, 100, 6.23);
  end;
  DWriteLn('Antiban finished!');
end;

{*******************************************************************************
function Randoms: Boolean;
Description: Everything for randoms.
*******************************************************************************}

function Randoms: Boolean;
var
  S: string;
begin
  if (not (LoggedIn)) then
    Exit;
  DWriteLn('Finding randoms...');
  if (FindNormalRandoms) then
  begin
    Result := True;
    Inc(Total[4]);
    Inc(TotalScript[5]);
    WriteINI('TotalScript', '5', IntToStr(TotalScript[5]), ScriptSettingsPath);
    Inc(Players[CurrentPlayer].Integers[6]);
    if (PlayRandomSound) then
    begin
      PlaySound(ScriptPath + 'resources\RandomSound.WAV');
      S := ' Playing sound to alert script user.';
    end;
    WriteLn('Random found! Performing anti-ban.' + S);
    AntiBan(1);
  end else
    DWriteLn('No randoms detected!');
end;

{*******************************************************************************
function CheckPick(var NotEquipped: Boolean): Boolean;
By: r!ch!e
Description: Finds PickHead. Returns True if Pick is found in either
 tab_Inv or tab_Equip and where it was found.
*******************************************************************************}

function CheckPick(var NotEquipped: Boolean): Boolean;
var
  Pick, x, y, curTab : Integer;
begin
  DWriteLn('Checking for pickaxe...');
  Pick := DTMFromString('78DA6374646260B8CB8001FE0331238806024' +
        '6909AEBE82A98C0242394C7680CE4DF26A0C61BC8BF47408D0D90' +
        'FF19BF1A002D910AB4');
  curTab := GetCurrentTab;
  GameTab(tab_Inv);
  if (FindDTM(Pick, x, y, MIX1, MIY1, MIX2, MIY2)) then
  begin
    Result := True;
    NotEquipped := True;
    DWriteLn('Pickaxe is NOT Equipped!');
  end
  else
  begin
    GameTab(tab_Equip);
    Result := FindDTM(Pick, x, y, MIX1, MIY1, MIX2, MIY2);
    DWriteLn('Pickaxe is Equipped!');
  end;
  DWriteLn('function CheckPick(var NotEquipped: Boolean): Boolean; : Returned : ' + BoolToStr(Result));
  FreeDTM(Pick);
  GameTab(curTab);
end;

function BankEss: Boolean; forward;

{*******************************************************************************
function InitPlayer: Boolean;
By: IceFire908.
Description: Sets up a user for mining, results false if failed to find any
active players to use.
*******************************************************************************}

function InitPlayer: Boolean;
var
  M: Boolean;
  I, II: Byte;
begin
  M := ((Players[CurrentPlayer].Booleans[0]) or (Players[CurrentPlayer].Booleans[1]) or (Players[CurrentPlayer].Booleans[2]) or (Players[CurrentPlayer].Booleans[3]) or (Players[CurrentPlayer].Strings[1] = '[Pure] (VEB)'));
  if ((M) and (not (CurrentlyMemberWorld))) then
  begin
    ChangeWorld(RandomWorld(True, False))
    CurrentlyMemberWorld := True;
  end
  else
    if ((CurrentlyMemberWorld) and (not (M))) then
    begin
      ChangeWorld(RandomWorld(False, False));
      CurrentlyMemberWorld := False;
    end;
  LogInPlayer;
  Wait(1000 + Random(500));
  Result := LoggedIn;
  if (not (Result)) then
    Exit;
  if (SRL_Logs < 1) then
    SRL_Logs := 1;
  Players[CurrentPlayer].Loc := 'Setting up...';
  WriteLn('Setting up player for essence mining...');
  SetAngle(True);
  MakeCompass('N');
  Wait(500 + Random(500));
  Players[CurrentPlayer].Pin := Players[CurrentPlayer].Strings[0];
  for I := 1 to 21 do
    Players[CurrentPlayer].Level[I] := GetSkillLevel(I);
  GameTab(tab_Inv);
  Wait(200 + Random(100));
  if (not (CheckPick(Players[CurrentPlayer].Booleans[4]))) then
  begin
    WriteLn('No pick found for ' + Capitalize(Players[CurrentPlayer].Name) + '!');
    LogOut;
    Exit;
  end;
  for I := 0 to 4 do
    if (Players[CurrentPlayer].Booleans[I]) then
      Inc(II);
  if (II > InvCount) then
    if (not (BankEss)) then
      Exit;
  AntiBan(AntiBanChance);
  Players[CurrentPlayer].Loc := Between('(', ')', Players[CurrentPlayer].Strings[1]) + '.';
  WriteLn('Player is set up for essence mining.');
end;



{*******************************************************************************
function SpiralMouseMulti_H(var fx, fy: Integer; x1, y1, x2, y2: Integer; PpC, aInc: Integer): Boolean;
By: Home
Description: Modded From Original SpiralMouse.
*******************************************************************************}

function SpiralMouseMulti_H(var fx, fy: Integer; x1, y1, x2, y2: Integer; PpC, aInc: Integer; uText: String): Boolean;
var
  aStep, a, rStep, rV, oB: Extended;
  pX, pY, ms: Integer;
  sP: TPoint;
  L2R: Boolean;
begin
  Result := False;
  ms := MouseSpeed;
  MouseSpeed := CMouseSpeed + RandomRange(-3, 3);
  sP := MiddleTPA([Point(x1, y1), Point(x2, y2)]);
  aStep := Pi / (aInc / 2);
  a := 0;
  rStep := (PpC / aInc);
  L2R := Random(2) = 0;
  DWriteLn('aStep: ' + FloatToStr(aStep) + ' rStep ' + FloatToStr(rStep));
  repeat
    rV := rV + rStep;
    pX := Round(rV * cos(a)) + sP.x;
    pY := Round(rV * sin(a)) + sP.y;
    if L2R then
      a := a + aStep
    else
      a := a - aStep;
    if InRange(pX, x1, x2) and InRange(pY, y1, y2) then
    begin
      oB := 0;
      MMouse(pX - 5, pY - 5, 0, 0);
      DWriteLn('Checking uptext!');
      if (IsUpText(uText)) then
      begin
        DWriteLn('True!');
        GetMousePos(fx, fy);
        Result := True;
      end else
        DWriteLn('False!');
    end else
      oB := oB + aStep;
  until Result or (oB > (2 * Pi));
  MouseSpeed := ms;
end;

{*******************************************************************************
function Walk(X, Y, F: LongInt; CheckFlag: Boolean): Boolean;
By: IceFire908
Description: Simple walking function that combines some higher level functions.
*******************************************************************************}

function Walk(X, Y, F: LongInt): Boolean;
begin
  MakeCompass('N');
  if (rs_OnMiniMap(X, Y)) then
  begin
    Mouse(X, Y, 0, 0, True);
    Result := FlagPresent;
    FFlag(F);
    DWriteLn('Flagging...');
    if F = 0 then Wait(RandomRange(700, 1000));
  end else
    DWriteLn('Points declared by Walk (' + IntToStr(X) + ', ' + IntToStr(y) + ') are NOT on runescape minimap!');
end;

{*******************************************************************************
function FindBankersMM(var x, y: Integer; Dis: Integer): Boolean;
By: Quickmarch
Description: Gets the x and y of the bankers.
*******************************************************************************}

function FindBankersMM(var x, y: Integer; Dis: Integer): Boolean;
var
  i: Integer;
  TPA: TPointArray;
  ATPA: T2DPointArray;
  TB: TBox;

begin
  DWriteLn('Gathering colours for bankers on MiniMap!');
  FindColorsSpiralTolerance(MMCX, MMCY, TPA, 195836, MMX1, MMY1, MMX2, MMY2, 0);
  DDebugTPA(TPA);
  if (Length(TPA) = 0) then
  begin
    WriteLn('FindBankers did not find any points.');
    Exit;
  end;
  ATPA := SplitTPAEx(TPA, 40, 10);
  for i := 0 to High(ATPA) do
    if (Length(ATPA[i]) > 16) then
    begin
      TB := GetTPABounds(ATPA[i]);
      x := ((TB.x1 + TB.x2) div 2);
      y := ((TB.y1 + TB.y2) div 2);
      Result := Distance(MMCX, MMCY, x, y) > Dis;
      ClearTPA;
      Exit;
    end;
  ClearTPA;
end;

{*******************************************************************************
function FindDoor(x, y: Integer; var c, u: Integer): Boolean;
By: Timer
Description: Finds if the door is open/closed.
*******************************************************************************}
function FindDoor(x, y: Integer; var c, u: Integer): Boolean;
var
  TPA: TPointArray;
begin
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.10, 0.12);
  DWriteLn('Gathering door colours!');
  FindColorsSpiralTolerance(x + 40, y - 10, TPA, 4417655, x + 20, y - 20, x + 60, y + 8, 4);
  ColorToleranceSpeed(1);
  SetColorSpeed2Modifiers(0.2, 0.2);
  DWriteLn('Checking length!');
  if (Length(TPA) > 15) then
  begin
    DWriteLn('Length is WIN!');
    MiddleTPAEx(TPA, c, u);
    MMouse(c, y, 5, 5);
    Wait(50 + Random(50));
    Result := IsUpText('pen ');
    if (Result) then
      DWriteLn('Uptext is WIN!!')
    else
      DWriteLn('No uptext.. Some one took it first..');
    GetMousePos(c, u);
  end else
    DWriteLn('Length failed!');
end;

{*******************************************************************************
function GlowingBall(x, y: Integer): Boolean;
By: Timer
Description: Finds a glowing ball.
*******************************************************************************}
function GlowingBall(x, y: Integer): Boolean;
var
  TPA: TPointArray;
begin
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.09, 0.82);
  DWriteLn('Gathering white colours!');
  FindColorsSpiralTolerance(x, y, TPA, 8817588, x - 30, y - 30, x + 30, y + 30, 22);
  ColorToleranceSpeed(1);
  SetColorSpeed2Modifiers(0.2, 0.2);
  Result := Length(TPA) > 8;
  if (Result) then
    DWriteLn('White stuff is around stick!')
  else
    DWriteLn('No white stuff was found!!');
end;

{*******************************************************************************
function FindGlowingStick: Integer;
By: Timer
Description: Finds a glowing stick.
*******************************************************************************}
function FindGlowingStick(var xx, yy: Integer): Boolean;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
  i, ii, x, y: Integer;
begin
  DWriteLn('Gathering colours for a glowing stick!!');
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.06, 0.80);
  FindColorsSpiralTolerance(MSCX, MSCY, TPA, 3761546, MSX1, MSY1, MSX2, MSY2, 15);
  ColorToleranceSpeed(1);
  SetColorSpeed2Modifiers(0.2, 0.2);
  ATPA := SplitTPA(TPA, 5);
  ii := High(ATPA);
  for i := 0 to ii do
  begin
    MiddleTPAEx(ATPA[i], x, y);
    DWriteLn('Checking that glowing stick has white around it!  [Shut up you perverts]');
    if (GlowingBall(x, y)) then
    begin
      Result := True;
      xx := x;
      yy := y;
      Break;
    end;
  end;
end;

{*******************************************************************************
procedure WalkToShop;
By: NaumanAkhlaQ, Home, Quickmarch, IceFire908, & Timer
Description: Walks to shop using various different fail safes.
*******************************************************************************}
procedure WalkToShop;
var
  CP: TPoint;
  _Temp: Extended;
begin
  if (not (LoggedIn)) then
    Exit;
  Players[CurrentPlayer].Loc := 'Walking to shop...';
  WriteLn('Walking to shop...');
  SetRun(True);
  Randoms;
  AntiBan(AntiBanChance);
  MakeCompass('N');
  if (UseReflection) then
  begin
    if (not WalkOurPath(ToMine)) then
      Exit;
  end else
  begin
    Mouse(RandomRange(640, 649), RandomRange(143, 152), 2, 2, True);
    Wait(7000);
    FFlag(10);
    Wait(1500 + Random(501));
    if (FindBankersMM(CP.x, CP.y, 0)) then
      if (Walk(CP.x + 2, CP.y + 70, 0)) then
        Exit;
    DWriteLn('Walking via symbol!');
    if (FindSymbol(CP.x, CP.y, 'magic shop')) then
      Walk(CP.x, CP.y, 0)
    else
    begin
      _Temp := SymbolAccuracy;
      SymbolAccuracy := 0.1;
      if (FindSymbol(CP.x, CP.y, 'magic shop')) then
        Walk(CP.x, CP.y, 0)
      else
        Walk(RandomRange(607, 615), RandomRange(102, 111), 0);
      SymbolAccuracy := _Temp;
    end;
  end;
  Randoms;
  WriteLn('Walked to shop.');
end;

{*******************************************************************************
function FindAubury(var ax, ay : Integer) : Boolean;
By: Camo Developer
Description: Finds Aubury and returns the X, Y coordinates
*******************************************************************************}

function FindAubury(var ax, ay : Integer) : Boolean;
var
  TPA: TPointArray;
  I, CTS, x, y, xx, yy: Integer;
  ATPA: T2DPointArray;
  o: TPoint;
  OldMS: Integer;
begin
  if (FindGlowingStick(x, y)) then
    if (FindDoor(x, y, xx, yy)) then
      if (IsUpText('pen ')) then
        Mouse(xx, yy, 0, 0, True);
  CTS := GetColorToleranceSpeed;
  OldMS := MouseSpeed;
  MouseSpeed := CMouseSpeed;
  DWriteLn('Adjusting mousespeed to ' + IntToStr(MouseSpeed) + '!');
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.26, 1.47);
  DWriteLn('Gathering colours for Aubury!');
  FindColorsTolerance(TPA, 1158634, MSX1, MSY1, MSX2, MSY2, 9);
  DDebugTPA(TPA);
  ColorToleranceSpeed(CTS);
  SetColorSpeed2Modifiers(0.2, 0.2);
  if (Length(TPA) = 0) then
  begin
    MouseSpeed := OldMS;
    Exit;
  end;
  SortTPAFrom(TPA, Point(MSCX, MSCY));
  ATPA := TPAToATPAEx(TPA, 15, 15);
  SortATPASize(ATPA, True);
  for I := 0 to High(ATPA) do
  begin
    o := MiddleTPA(ATPA[i]);
    MMouse(o.x, o.y, 3, 3);
    Wait(200 + Random(100));
    Result := (CountColorTolerance(648165, 7, 7, 100, 25, 50) > 130);
    DWriteLn('Checking "uptext"!');
    if(Result)then
    begin
      DWriteLn('Resulted true!');
      GetMousePos(ax, ay);
      MouseSpeed := OldMS;
      ClearTPA;
      Exit;
    end;
  end;
  ClearTPA;
  MouseSpeed := OldMS;
end;

{*******************************************************************************
procedure TeleportAubury;
By: IceFire908 & J_pizzle
Description: Teleports to the ess mine using Aubury.
*******************************************************************************}

procedure TeleportAubury;
var
  T, Count: Integer;
  TA: TPoint;
begin
  if (not (LoggedIn)) then
    Exit;
  Players[CurrentPlayer].Loc := 'Looking for Aubury...';
  DWriteLn('Looking for Aubury...');
  T := GetSystemTime;
  repeat
    Inc(Count);
    if (FindAubury(TA.X, TA.Y)) then
      Mouse(TA.X, TA.Y, 3, 3, False)
    else
      if (Count = 2) then
        SetAngle(True);
      if ((Count mod 5) = 0) then
      begin
        MMouse(MSCX, MSCY, 4, 4);
        Wait(200 + Random(100));
        if (CountColorTolerance(648165, 7, 7, 100, 25, 50) > 130) then
        begin
          GetMousePos(TA.X, TA.Y);
          Mouse(TA.X, TA.Y, 3, 3, False);
        end;
      end;
    Wait(300 + Random(500));
  until (((GetSystemTime - T) > 30000 ) or (ChooseOption('elep')));
  if ((GetSystemTime - T) > 30000) then
  begin
    WriteLn('Failed to teleport to mine.');
    LogOut;
  end;
  DWriteLn('Found Aubury.');
  Flag;
  Randoms;
  WriteLn('Teleported to mine.');
end;

{*******************************************************************************
function GetSpawnLocation: string;
By: IceFire908.
Description: Scans the MiniMap for non-black values and compares them with
the six different spawn locations. Credits to Wizzup? for concept & ScanMM.
*******************************************************************************}

function GetSpawnLocation: string;
var
  TPA, dTPA, Dirr: TPointArray;
  D, MinC: TIntegerArray;
  Dir: TStringArray;
  T: Integer;
  I: Byte;
  tP: TPoint;
label
  LastResort;
begin
  T := GetSystemTime;
  DWriteLn('Determening Spawn Location..');
  repeat
    Wait(500 + Random(500));
  until ((CountColorTolerance(394503, MMX1, MMY1, MMX2, MMY2, 10) > 2000) or (GetSystemTime - T > 10000));
  if (UseReflection) then
  begin
    {$IFDEF REFLECTION}
    tP := Point(GetLocation.x, GetLocation.y);
    Dir := ['South West', 'North West', 'North East', 'South East', 'Middle South', 'Middle North'];
    Dirr := [Point(2896, 4809), Point(2896, 4845), Point(2923, 4846), Point(2925, 4818),
    Point(2906, 4826), Point(2912, 4833)];
    for I := 0 to 5 do
      if (tP.x = Dirr[I].x) then
        if (tP.y = Dirr[I].y) then
        begin
          Result := Dir[I];
          Exit;
        end;
    Writeln('Kidding me..?');
    goto LastResort;
    {$ENDIF}
  end else
  begin
    LastResort:
    Dir := ['South West', 'North West', 'North East', 'South East'];
    MinC := [100, 400, 500, 350];
    SetArrayLength(D, 4);
    Result := 'Unknown';
    T := GetSystemTime;
    DWriteLn('Determening Spawn Location..');
    FindColorsTolerance(TPA, clWhite, MMX1, MMY1, MMX2, MMY2, 421);
    DDebugTPA(TPA);
    for I := 0 to 3 do
    begin
      dTPA := TPA;
      FilterPointsPie(dTPA, 0 + (90 * I), 90 + (90 * I), 65, 75, MMCX, MMCY);
      D[I] := Length(dTPA);
    end;
    if ((D[0] > 100) and (D[1] > 100) and (D[2] > 100) and (D[3] > 100)) then
    begin
      dTPA := TPA;
      FilterPointsPie(dTPA, 180, 270, 0, 75, MMCX, MMCY);
      if (Length(dTPA) > 2500) then
      begin
        Result := 'Middle South';
      end
      else
      begin
        Result := 'Middle North';
      end;
      ClearTPA;
      DWriteLn('Resulted: ' + Result + '!');
      Exit;
    end;
    for I := 0 to 3 do
      if (D[I] > MinC[I]) then
      begin
        Result := Dir[I];
      end;
    ClearTPA;
    DWriteLn('Resulted: ' + Result + '!');
  end;
end;

{*******************************************************************************
function FindEssSourceFast(var gx, gy : integer) : boolean;
By: Home, Timer
Description: Finds Essence using SpiralMouse.
*******************************************************************************}

function FindEssSourceFast(var gx, gy: integer): boolean;
begin
  DWriteLn('Finding essence...Fast! :p');
  if SpiralMouseMulti_H(gx, gy, MSX1, MSY1, MSX2, MSY2, 50, 80, 'ine') then
    Result := True;
end;


{*******************************************************************************
function FindEssSource(var x, y: Integer): Boolean;
By: Quickmarch
Description: Finds the ess source.
*******************************************************************************}

function FindEssSource(var x, y: Integer): Boolean;
var
  TPA : TPointArray;
  I, II, CTS, OldMS: Integer;
  ATPA, SourceATPA: T2DPointArray;
  P: TPoint;

begin
  Players[CurrentPlayer].Loc := 'Looking for essence source...';
  DWriteLn('Searching for essence...');
  CTS := GetColorToleranceSpeed;
  OldMS := MouseSpeed;
  MouseSpeed := CMouseSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.08, 0.19);
  DWriteLn('Gathering essence colours...');
  FindColorsSpiralTolerance(MSCX, MSCY, TPA, 8948375, MSX1, MSY1, MSX2, MSY2, 28);
  DDebugTPA(TPA);
  ColorToleranceSpeed(CTS);
  SetColorSpeed2Modifiers(0.2, 0.2);
  if(Length(TPA) = 0)then
  begin
    WriteLn('FindEssSource could not find any points.');
    MouseSpeed := OldMS;
    Exit;
  end;
  ATPA := SplitTPAEx(TPA, 5, 5);
  SortATPAFrom(ATPA, Point(MSCX, MSCY));
  SortATPASize(ATPA, True);
  for I := 0 to High(ATPA) do
    if (Length(ATPA[i]) >= 4000) then
    begin
      SourceATPA := TPAToATPAEx(ATPA[i], 30, 30);
      SortATPAFrom(SourceATPA, Point(MSCX, MSCY));
      for ii := 0 to High(SourceATPA) do
        if (Length(SourceATPA[ii]) > 250) then
        begin
          P := MiddleTPA(SourceATPA[ii]);
          MMouse(P.x, P.y-5, 3, 3);
          Wait(200 + Random(100));
          DWriteLn('Checking "uptext"..');
          Result := (CountColorTolerance(14342657, 7, 7, 100, 25, 70) > 100);
          if (Result) then
          begin
            DWriteLn('Uptext found!');
            GetMousePos(x, y);
            MouseSpeed := OldMS;
            ClearTPA;
            Exit;
          end;
    end;
  end;
  ClearTPA;
  MouseSpeed := OldMS;
end;

{*******************************************************************************
Function FindEssence(var gx, gy : integer) :Boolean;
By: Home, Timer
Description: Combines 2 Essence Finding Functions.
*******************************************************************************}

function FindEssence(var gx, gy: integer): Boolean;
begin
  if FindEssSource(gx, gy) then
    Result := True
  else
    if FindEssSource(gx, gy) then
      Result := True
    else
      Result := FindEssSourceFast(gx, gy);
end;


{*******************************************************************************
function FillInventoryWithEssence: Boolean;
By: IceFire908, Timer
Description: Finds mine source and waits until inventory is full while checking randoms.
*******************************************************************************}

function FillInventoryWithEssence: Boolean;
var
  T, R, RT, _InvCount, _TInvCount: Integer;
  Left: Boolean;
  ES: TPoint;
begin
  DWriteLn('Begin mining essence..');
  if  FindEssence(ES.X, ES.Y) then
  begin
    Left :=  (not (Random(4) = 0));
    Mouse(ES.X, ES.Y, 0, 0, Left);
    if (not (Left)) then
    begin
      Wait(500 + Random(500));
      ChooseOption('ine');
    end;
    R := Random(120000);
    T := GetSystemTime;
    _InvCount := InvCount;
    _TInvCount := GetSystemTime + 10000;
    repeat
      DWriteLn('Waiting for full inventory...');
      Wait(1000 + Random(2000));
      if (InvCount = _InvCount) then
      begin
        if (GetSystemTime > _TInvCount) then
          if FindEssence(ES.X, ES.Y) then
          begin
            Left :=  (not (Random(4) = 0));
            Mouse(ES.X, ES.Y, 0, 0, Left);
            if (not (Left)) then
            begin
              Wait(500 + Random(500));
              ChooseOption('ine');
            end;
            _InvCount := InvCount;
            _TInvCount := GetSystemTime + 10000;
          end;
      end else
      begin
        _InvCount := InvCount;
        _TInvCount := GetSystemTime + 10000;
      end;
      RT := GetSystemTime;
      if (Randoms) then
      begin
        Wait(3000 + Random(5000));
        if FindEssence(ES.X, ES.Y) then
        begin
          Left :=  (not (Random(4) = 0));
          Mouse(ES.X, ES.Y, 0, 0, Left);
          if (not (Left)) then
          begin
            Wait(500 + Random(500));
            ChooseOption('ine');
          end;
          IncEx(T, GetSystemTime - RT);
        end else
          LogOut;
      end;
      if (InvCount < 25) then
        AntiBan(100);
    until ((InvFull) or ((GetSystemTime - T) > (180000 + R)) or (not (LoggedIn)));
    Result := LoggedIn;
    if (Result) then
    begin
      DWriteLn('Inventory full!');
      Exit;
    end;
  end;
  WriteLn('Could not find essence source.');
  if (LoggedIn) then
    LogOut;
end;

{*******************************************************************************
procedure ClickPouch2(Pouch, Option: String; Tol: Integer);
By: Psychor & Wizzup? Fixed by IceFire908
Description: Click Pouch
*******************************************************************************}

procedure ClickPouch2(Pouch, Option: string);
var
  x, y, i, PouchMark, Current, dtm: Integer;
  b: Boolean;
begin
  MarkTime(PouchMark);
  Current := InvCount;
  DWriteLn('Clicking pouch : ' + Pouch + ' - ' + Option);
  case LowerCase(Pouch) of
    'small': dtm := DTMFromString('78DA63DCC9C0C070870103FC076246100D048' +
                  'C1B808C4BE82A98C0242394C77810485C21A00664CE03026AF603' +
                  '8947F8D500001CEB0CEB');
    'medium': dtm := DTMFromString('78DA63EC656060B8C78001FE033123880602C' +
                   '65620E312BA0A2630C908E5314E25424D0F903847400DC8AE4704' +
                   'D44C06124F08A801F9EB397E3500B06C0EEB');
    'large': dtm := DTMFromString('78DA634C646060B8CF8001FE033123880602C' +
                  '62820E312BA0A2630C908E5312601898B04D4640089CB04D4E400' +
                  '894704D48412A1261648BC20A02695B01A00223E0F0B');
    'giant': dtm := DTMFromString('78DA6334656060B8C78001FE0331238806024' +
                  '65D20E33CBA0A2630C908E5319A0189B304D4D811618E0B36F7A0' +
                  'A95127428D01907849408D3561350039310D9D');

    else Exit;
  end;
  if FindDTM(dtm, x, y, MIX1, MIY1, MIX2, MIY2)then
  begin
    i := coordstoitem(x, y);
    b := True;
    case LowerCase(Option) of
      'fill': begin
                MouseItem(i, True); //Mouse(x, y, 2, 2, True);
              end;
      'empty': begin
                 MouseItem(i, False); //Mouse(x, y, 2, 2, False);
                 Wait(400 + Random(50));
                 ChooseOptionMulti(['mpt', 'Emp', 'mpty']);
               end;
      'check': begin
                 MouseItem(i, False); //Mouse(x, y, 2, 2, False);
                 Wait(400 + Random(50));
                 ChooseOptionMulti(['hec', 'Che', 'heck']);
               end;
      else b := False;
    end;
  end;
  FreeDTM(dtm);
  if (not b) then Exit;
  while (Current = InvCount) do
  begin
    Wait(100 + Random(50));
    if (TimeFromMark(PouchMark) > 2500) then
      Exit;
  end;
  Wait(RandomRange(1000, 1200));
end;

{*******************************************************************************
function FindPortal(var px, py : Integer) : Boolean;
By: Camo Developer, fixed by Quickmarch
Description: Find the Portal to teleport out of the Essence Mine.
*******************************************************************************}

function FindPortal(var px, py : Integer) : Boolean;
var
  TPA           : TPointArray;
  I, CTS        : Integer;
  ATPA          : T2DPointArray;
  o             : TPoint;
  OldMS         : Integer;
begin
  CTS := GetColorToleranceSpeed;
  OldMS := MouseSpeed;
  MouseSpeed := CMouseSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.51, 3.91);
  DWriteLn('Gathering portal colours!');
  FindColorsTolerance(TPA, 12114645, MSX1, MSY1, MSX2, MSY2, 10);
  DDebugTPA(TPA);
  ColorToleranceSpeed(CTS);
  SetColorSpeed2Modifiers(0.2, 0.2);
  if(Length(TPA) = 0)then
  begin
    WriteLn('FindPortal could not find any points.');
    MouseSpeed := OldMS;
    Exit;
  end;
  SortTPAFrom(TPA, Point(MSCX, MSCY));
  ATPA := TPAToATPAEx(TPA, 10, 10);
  for I := 0 to High(ATPA) do
  begin
    o := MiddleTPA(ATPA[i]);
    MMouse(o.x, o.y, 3, 3);
    Wait(200 + Random(100));
    DWriteLn('Checking uptext!');
    Result := IsUpTextMultiCustom(['Enter', 'Portal', 'ortal', 'er Por']) Or
    (CountColorTolerance(14342657, 7, 7, 100, 25, 50) > 50)
    if (Result) then
    begin
      DWriteLn('Resulted true!');
      GetMousePos(px, py);
      MouseSpeed := OldMS;
      ClearTPA;
      Exit;
    end;
  end;
  ClearTPA;
  MouseSpeed := OldMS;
end;

{*******************************************************************************
function TeleportOut: Boolean;
By: Camo Developer & IceFire908
Description: Teleports out of the Essence Mine.
*******************************************************************************}

function TeleportOut: Boolean;
var
  Left: Boolean;
  M: Integer;
  T: TPoint;
begin
  Players[CurrentPlayer].Loc := 'Looking for exit portal...';
  WriteLn('Looking for exit portal...');
  M := GetSystemTime;
  repeat
    if (FindPortal(T.X, T.Y)) then
    begin
      Left :=  (not (Random(4) = 0));
      Mouse(T.X, T.Y, 2, 2, Left);
      if (not (Left)) then
      begin
        Wait(500 + Random(500));
        ChooseOption('nter');
      end;
      Wait(1000 + Random(500));
    end;
    Wait(2000 + Random(1000));
  until (((GetSystemTime - M) > 20000) or (CountColorTolerance(394503, MMX1, MMY1, MMX2, MMY2, 10) < 2000) or (GetColor(58, 13) = 0));
  Result := ((GetSystemTime - M) < 20000);
  if (not (Result)) then
    Exit;
  WriteLn('Found portal.');
  M := GetSystemTime;
  repeat
    Wait(500 + Random(500));
  until ((CountColorTolerance(394503, MMX1, MMY1, MMX2, MMY2, 10) < 2000) or (GetSystemTime - M > 10000) or (Randoms));
end;

{*******************************************************************************
procedure MineEssence;
By: IceFire908
Description: Finds spawn location, walks to mine, finds essence source, fills pouches
and inventory, and finally exits through the portal.
*******************************************************************************}

procedure MineEssence;
var
  Locations, PNames, U: TStringArray;
  PAmounts: TIntegerArray;
  Location, N, S: string;
  Pouches: TBooleanArray;
  EP: TPointArray;
  I, II: Integer;
begin
  if (not (LoggedIn)) then
    Exit;
  Randoms;
  Locations := ['North West', 'North East', 'Middle North', 'Middle South', 'South West', 'South East'];
  EP := [Point(595, 72), Point(655, 68), Point(654, 65), Point(607, 98), Point(615, 83), Point(654, 97)];
  Location := GetSpawnLocation;
  if (Location = 'Unknown') then
  begin
    WriteLn('Player got lost after teleporting.');
    Players[CurrentPlayer].Loc := 'Got lost after teleport Aubury.';
    LogOut;
    Exit;
  end;
  WriteLn('Spawned in ' + Location + ' area.');
  if (Location = 'South West') then
  begin
    Walk(RandomRange(617, 619), RandomRange(75, 77), 0);
    Wait(1000 + Random(500));
  end;
  if (Location = 'North East') then
  begin
    Walk(RandomRange(636, 638), RandomRange(67, 69), 0);
    Wait(1000 + Random(500));
  end;
  if (Location = 'Middle North') then
  begin
    Walk(RandomRange(653, 655), RandomRange(54, 56), 0);
    Walk(RandomRange(649, 651), RandomRange(52, 54), 0);
    Wait(1000 + Random(500));
    WriteLn('Mining in North East.');
  end
  else
    if (Location = 'Middle South') then
    begin
      Walk(RandomRange(585, 587), RandomRange(127, 129), 0);
      Wait(1000 + Random(500));
      WriteLn('Mining in South West.');
    end
    else
      WriteLn('Mining in ' + Location + '.');
  Players[CurrentPlayer].Loc := 'Last seen in the ' + Location + ' area.';
  SetArrayLength(U, 4);
  EssenceBeingCarried := 27;
  PAmounts := [2, 5, 8, 11];
  PNames := ['small', 'medium', 'large', 'giant'];
  N := ' being used for ' + Capitalize(Players[CurrentPlayer].Name) + '.';
  Pouches := [Players[CurrentPlayer].Booleans[0], Players[CurrentPlayer].Booleans[1], Players[CurrentPlayer].Booleans[2], Players[CurrentPlayer].Booleans[3]];
  if (not (FillInventoryWithEssence)) then
    Exit;
  if ((Pouches[0]) or (Pouches[1]) or (Pouches[2]) or (Pouches[3])) then
  begin
    for I := 0 to 3 do
      if (Pouches[I]) then
      begin
        U[II] := PNames[I];
        Inc(II);
      end;
    case II of
      1: S := ' pouch';
      2: S := ' and ' + U[1] + ' pouches';
      3: S := ', ' + U[1] + ', and ' + U[2] + ' pouches';
      4: S := ', ' + U[1] + ', ' + U[2] + ', and ' + U[3] + ' pouches';
    end;
    WriteLn(Capitalize(U[0]) + S + N);
    for I := 0 to 3 do
      if (Pouches[I]) then
      begin
        IncEx(EssenceBeingCarried, PAmounts[I]);
        if (EssenceBeingCarried > 50) then
          if (not (FillInventoryWithEssence)) then
            Exit;
        ClickPouch2(PNames[I], 'Fill');
      end;
    if (not (FillInventoryWithEssence)) then
      Exit;
  end
  else
    WriteLn('No pouches' + N);
  if (not (Players[CurrentPlayer].Booleans[4])) then
    Inc(EssenceBeingCarried);
  IncEx(Total[0], EssenceBeingCarried);
  IncEx(TotalScript[1], EssenceBeingCarried);
  WriteINI('TotalScript', '1', IntToStr(TotalScript[1]), ScriptSettingsPath);
  IncEx(Players[CurrentPlayer].Integers[2], EssenceBeingCarried);
  IncEx(Total[1], EssenceBeingCarried * 5);
  IncEx(TotalScript[2], EssenceBeingCarried * 5);
  WriteINI('TotalScript', '2', IntToStr(TotalScript[2]), ScriptSettingsPath);
  IncEx(Players[CurrentPlayer].Integers[3], EssenceBeingCarried * 5);
  InStrArrEx(Location, Locations, I);
  Walk(RandomRange((EP[I].X - 1), (EP[I].X + 1)), RandomRange((EP[I].Y - 1), (EP[I].Y + 1)), 0);
  Wait(1000 + Random(500));
  if (TeleportOut) then
    Exit;
  WriteLn('Could not find portal.');
  Players[CurrentPlayer].Loc := 'Looking for the portal...';
  LogOut;
end;

{*******************************************************************************
function WalkInVEB(MinDist: Integer): Boolean;
By: IceFire908.
Description: Walks into Varrock East Bank infront of the middle bank booth,
returns true if the Bankers NPC yellow dots found on MM, will not walk if char
is within MinDist (pixels) from the desired location. Put 0 for dummies.
*******************************************************************************}

function WalkInVEB(MinDist: Integer): Boolean;
var
  dtmVEBBankers: Integer;
  WIV: TPoint;
begin
  MakeCompass('N');
  DWriteLn('Walking into VEB infont of bankers!');
  dtmVEBBankers := DTMFromString('78DA632C65626008654001FFFEFD63D0616460002286FF40C0980954130B916382AAF9F38789418A01A20604187389505348849A5222D45411A1A68EB01A0089791970');
  if (DTMRotated(dtmVEBBankers, WIV.X, WIV.Y, MMX1, MMY1, MMX2, MMY2)) then
  begin
    Result := True;
    if (Distance(WIV.X, WIV.Y + 7, MMCX, MMCY) > MinDist) then
    begin
      Walk(WIV.X, WIV.Y + 5, 0);
      Wait(1500 + Random(501));
    end;
  end;
  FreeDTM(dtmVEBBankers);
end;

{*******************************************************************************
procedure WalkToBank;
By: IceFire908 and Quickmarch
Description: Walks from shop to bank.
*******************************************************************************}

procedure WalkToBank;
var
  WTB: TPoint;
  BP: TPoint;
  x, y, xx, yy: Integer;
begin
  if (not (LoggedIn)) then
    Exit;
  WriteLn('Walking to bank...');
  Players[CurrentPlayer].Loc := 'Walking to bank...';
  if (UseReflection) then
  begin
    if (not WalkOurPath(ToBank)) then
      Exit;
  end else
  begin
    MakeCompass('N');
    if (FindGlowingStick(x, y)) then
      if (FindDoor(x, y, xx, yy)) then
        if (IsUpText('pen ')) then
          Mouse(xx, yy, 0, 0, True);
    if (not (FindBankersMM(BP.x, BP.y, 40))) then
    begin
      Walk(RandomRange(647, 649), RandomRange(51, 53), RandomRange(3, 7));
      if (not (WalkInVEB(4))) then
        if (not (FindBankersMM(BP.x, BP.y, 40))) then
         if (not (FindSymbol(WTB.X, WTB.Y, 'Bank'))) then
           Walk(RandomRange(606, 608), RandomRange(50, 52), 0)
         else
           Walk(WTB.X, WTB.Y, 0)
        else
          Walk(BP.x, BP.y-7, 0);
    end
    else
      Walk(BP.x, BP.y-7, 0);
  end;
  Players[CurrentPlayer].Loc := Between('(', ')', Players[CurrentPlayer].Strings[1]) + '.';
  WriteLn('Walked to bank.');
end;

{*******************************************************************************
function OpenVEB: Boolean;
By: IceFire908 & Home
Description: Opens varrock east bank.
*******************************************************************************}

function OpenVEB: Boolean;
var
  TPAA: T2DPointArray;
  Use: TStringArray;
  TPA: TPointArray;
  I, T: LongInt;
  OB: TPoint;
begin
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.11, 1.70);
  DWriteLn('Gathering colours for bank!');
  FindColorsSpiralTolerance(MSCX, MSCY, TPA, 2115671, MSX1, MSY1, MSX2, MSY2, 5);
  DDebugTPA(TPA);
  SetColorSpeed2Modifiers(0.2, 0.2);
  ColorToleranceSpeed(1);
  if (Length(TPA) < 1) then
    Exit;
  TPAA := TPAToATPAEx(TPA, 30, 30);
  SortATPAFromFirstPoint(TPAA, Point(MSCX, MSCY));
  for I := 0 to High(TPAA) do
  begin
    if (Length(TPAA[I]) < 100) then
      Continue;
    OB := MiddleTPA(TPAA[I]);
    MMouse(OB.X, OB.Y, 1, 1);
    Wait(200 + Random(50));
    DWriteLn('Checking uptexts and choosing options accordingly!');
    Use := [];
    if (CountColorTolerance(14342657, 7, 7, 100, 25, 70) > 150) then
      Use := ['quick', 'uick', 'uic']
    else
      if (CountColorTolerance(648165, 7, 7, 100, 25, 50) > 100) then
        Use := ['ank B', 'nk B', 'k Ba'];
    if (Length(Use) > 0) then
    begin
      DWriteLn('Found uptext!');
      GetMousePos(OB.X, OB.Y);
      Mouse(OB.X, OB.Y, 0, 0, False);
      Wait(200 + Random(50));
      ChooseOptionMulti(Use);
      FFlag(0);
      MarkTime(T);
      while (not ((BankScreen) or (PinScreen) or (TimeFromMark(T) > 5000))) do
        Wait(100);
      Wait(RandomRange(300, 500));
      if (PinScreen) then
        if (Players[CurrentPlayer].Pin <> '') then
          InPin(Players[CurrentPlayer].Pin);
      Result := BankScreen;
      if (Result) then
        DWriteLn('Bank was opened!');
      ClearTPA;
      Exit;
    end;
  end;
  ClearTPA;
end;

{*******************************************************************************
function PointInMS(Point: TPoint): Boolean;
By: Home
Description: Checks do Point Exist on Mainscreen.
*******************************************************************************}

function PointInMS(Point: TPoint): Boolean;
begin
  Result := PointInBox(Point, IntToBox(MSX1, MSY1, MSX2, MSY2));
  if (not Result) then
    DWriteLn('Invalid point! (' + IntToStr(Point.x) + ', ' + IntToStr(Point.y) + ')');
end;

{*******************************************************************************
function FindObjectMM(WhatDot :String; ObjectUpText :TStringArray): Boolean;
By: Home
Description: Find's NPC's from Mainscreen without color.
*******************************************************************************}

function FindObjectMM(WhatDot :String; ObjectUpText :TStringArray): Boolean;
var
  TPA: TPointArray;
  P: TPoint;
  I, Hi: Integer;

begin
  if (BankScreen) then
  begin
    Result := True;
    Exit;
  end;
  Result := False;
  TPA := GetMiniMapDots(WhatDot);
  Hi := High(TPA);
  for I := 0 to Hi do
  begin
    P := MMToMS(TPA[I]);
    if not PointInMS(P) then Exit;
    DWriteLn('Checking uptext of NPC''s!');
    MMouse(P.X, P.Y - 20 + Random(10), 0, 0);
    if WaitUptextMulti(ObjectUpText, 300) Or
    (CountColorTolerance(14342657, 7, 7, 100, 25, 70) > 150) then
    begin
      DWriteLn('Found uptext!');
      Result := True;
      GetMousePos(P.X, P.Y);
      Mouse(P.X, P.Y, 0, 0, False);
      Exit;
    end;
  end;
end;

{*******************************************************************************
function OpenBankFastNPC: Boolean;
By: Home
Description: Opens Bank Using NPC's Or Booth's.
*******************************************************************************}

function OpenBankFastNPC: Boolean;
var
  OldMS, c: Integer;
begin
  FFlag(0);
  DWriteLn('Opening bank via NPC!');
  Wait(RandomRange(500, 1000));
  OldMS := MouseSpeed;
  MouseSpeed := CMouseSpeed;
  DWriteLn('Mousespeed increased to ' + IntToStr(MouseSpeed) + '!');
 If FindObjectMM('npc', ['ooth', 'anker']) then
    WaitOptionMulti(['ank B', 'quick'], 300);
      FFLag(0);
      MarkTime(c);
      repeat
        Wait(100);
      until (BankScreen) or (PinScreen) or (TimeFromMark(c) > 3500);
      Wait(Random(300));
      if (Players[CurrentPlayer].Pin <> '') then
        InPin(Players[CurrentPlayer].Pin);
      Result := (BankScreen) or (PinScreen);
  MouseSpeed := OldMS;
end;

{*******************************************************************************
function OpenBankSlow: Boolean;
By: Quickmarch
Description: Opens the bank with spiral mouse.
*******************************************************************************}

function OpenBankSlow: Boolean;
var
  x, y, i: Integer;

begin
  DWriteLn('Last resort banking...');
  for i := 0 to 3 do
  begin
    Result := SpiralMouseMulti_H(x, y, MSX1, MSY1, MSX2, MSY2, 30, 100, 'ooth');
    if Result then
    begin
      DWriteLn('It Worked!');
      Mouse(x, y+7, 3, 3, False);
      Wait(200);
      Result := ChooseOption('uick');
      if Result then Break;
    end;
  end;
end;

{*******************************************************************************
function BankEss: Boolean;
By: IceFire908
Description: Opens bank and deposits available essence.
*******************************************************************************}

function BankEss: Boolean;
var
  I, II, III: Byte;
begin
  if (not (LoggedIn)) then
    Exit;
  Flag;
  DWriteLn('Banking essence..');
  if (not (OpenVEB)) then
    if (not (OpenBankFastNPC)) then
      if (not (OpenBankFast('veb'))) then
        if (not (OpenBankSlow)) then
        begin
          WriteLn('Unable to find bankers');
          Players[CurrentPlayer].Loc := 'Couldn''t open bank...';
          LogOut;
          Exit;
        end;
  for I := 0 to 4 do
    if (Players[CurrentPlayer].Booleans[I]) then
      Inc(II);
  for I := 0 to 3 do
    if (Players[CurrentPlayer].Booleans[I]) then
      Inc(III);
  Deposit(1 + II, 28, True);
  if (III > 0) then
    CloseBank;
  Result := True;
  Inc(Banks);
  Inc(Total[3]);
  Inc(TotalScript[4]);
  WriteINI('TotalScript', '4', IntToStr(TotalScript[4]), ScriptSettingsPath);
  Inc(Players[CurrentPlayer].Banked);
  Inc(Players[CurrentPlayer].Integers[5]);
end;

{*******************************************************************************
procedure POMSEMBanking;
By: IceFire908
Description: Everything for banking.
*******************************************************************************}

procedure POMSEMBanking;
var
  PAmounts: TIntegerArray;
  PNames: TStringArray;
  I, EBC: {$IFDEF Simba}Integer;{$ELSE}Byte;{$ENDIF}
begin
  if (not (LoggedIn)) then
    Exit;
  WriteLn('Banking...');
  Players[CurrentPlayer].Loc := 'Banking...';
  EBC := 27;
  PAmounts := [2, 5, 8, 11];
  PNames := ['small', 'medium', 'large', 'giant'];
  if (not (BankEss)) then
    Exit;
  for I := 0 to 3 do
    if (Players[CurrentPlayer].Booleans[I]) then
    begin
      IncEx(EBC, PAmounts[I]);
      if (EBC > 50) then
        if (not (BankEss)) then
          Exit;
      ClickPouch2(PNames[I], 'Empty');
    end;
  if (EBC > 28) then
    if (not (BankEss)) then
      Exit;
  Players[CurrentPlayer].Loc := Between('(', ')', Players[CurrentPlayer].Strings[1]) + '.';
  WriteLn('Finished banking.');
end;

{*******************************************************************************
procedure ProgressReport;
By: IceFire908
Description: An elaborate display of progress.
*******************************************************************************}

procedure ProgressReport;
var
  WeAreActive, PlayerRand, PlayerRands: string;
  TCounter, I, T: LongInt;
  LI: Boolean;
begin
  if (Total[2] = 1) then
  begin
    Inc(TotalScript[0]);
    WriteINI('TotalScript', '0', IntToStr(TotalScript[0]), ScriptSettingsPath);
  end;
  if (TotalScript[0] = 0) then
    TotalScript[0] := 1;
  WriteLn('Displaying progress report...');
  TCounter := (1 + ((GetSystemTime - TimeStarted) div 1000));
  WriteLn('');
  WriteLn('<------===== POMS Essence Miner Progress Report =====------>');
  if (UseReflection) then
    Writeln('<------=====          Using Reflection Methods          =====------>');
  WriteLn('           Script run # ' + IntToStr(TotalScript[0]) + ' - ' + TheDate(1) + ' - ' + TheTime + '.');
  WriteLn('  Total run time:                        ' + TimeRunning);
  WriteLn('  Total essence mined:                   ' + IntToStr(Total[0]));
  WriteLn('  Total essence using script mined:      ' + IntToStr(TotalScript[1]));
  WriteLn('  Avg. total ess per a script run:       ' + IntToStr(Round(TotalScript[1]div TotalScript[0])));
  WriteLn('  Essence per hour:                      ' + IntToStr(Round((3600 * (Total[0])) div (TCounter))));
  WriteLn('  Total trips made:                      ' + IntToStr(Total[2]));
  WriteLn('  Total trips using script made:         ' + IntToStr(TotalScript[3]));
  WriteLn('  Avg. total trips made per script run:  ' + IntToStr(Round(TotalScript[3]div TotalScript[0])));
  WriteLn('  Trips per hour:                        ' + IntToStr(Round((3600 * (Total[2])) div (TCounter))));
  WriteLn('  Total banks:                           ' + IntToStr(Total[3]));
  WriteLn('  Total banks using script:              ' + IntToStr(TotalScript[4]));
  WriteLn('  Avg. total banks per script run:       ' + IntToStr(Round(TotalScript[4]div TotalScript[0])));
  WriteLn('  Banks per hour:                        ' + IntToStr(Round((3600 * (Total[3])) div (TCounter))));
  WriteLn('  Total Mining EXP gained:               ' + FloatToStr(Total[1]));
  WriteLn('  Total Mining EXP gained using script:  ' + FloatToStr(TotalScript[2]));
  WriteLn('  Avg. Mining EXP gained per script run: ' + IntToStr(Round(TotalScript[2]div TotalScript[0])));
  WriteLn('  Mining EXP per hour:                   ' + IntToStr(Round((3600 * (Total[1])) div (TCounter))));
  if (TotalScript[5] > 0) then
  begin
    WriteLn('  Total randoms found:                   ' + IntToStr(Total[4]));
    WriteLn('  Total randoms found using script:      ' + IntToStr(TotalScript[5]));
    WriteLn('  Avg. randoms found per script run:     ' + IntToStr(Round(TotalScript[5] div TotalScript[0])));
  end;
  WriteLn('  Current player:                        ' + Capitalize(Players[CurrentPlayer].Name));
  WriteLn('  Player currently:                      ' + Players[CurrentPlayer].Loc);
  WriteLn('[ ----------------------------------------------------------------------- ]');
  WriteLn('');
  WriteLn('<------===== POMS Essence Miner Player''s Report =====------>');
  for I := 0 to (HowManyPlayers - 1) do
  begin
    PlayerRand := '';
    PlayerRands := '';
    if (Players[I].Active) then
      WeAreActive := '  (Active)  -- Ess: '
    else
      WeAreActive := ' (InActive) -- Ess: ';
    if (not (Players[I].Rand = '')) then
      PlayerRand := ' -- Rand: ' + Players[I].Rand;
    if (Players[I].Integers[6] > 0) then
      PlayerRands := ' -- Randoms: ' + IntToStr(Players[I].Integers[6]);
    WriteLn('  ' + Capitalize(Players[I].Name) + WeAreActive + IntToStr(Players[I].Integers[2]) + ' -- Trips: ' + IntToStr(Players[I].Integers[4]) + ' -- Loc: ' + Players[I].Loc + ' -- EXP: ' + IntToStr(Players[I].Integers[3]));
    WriteLn('  ' + ' -- Banks: ' + IntToStr(Players[I].Banked) + ' -- Mining Level: ' + IntToStr(Players[I].Level[15]) + PlayerRands + PlayerRand);
  end;
  WriteLn('[ ----------------------------------------------------------------------- ]');
  WriteLn('');
  {GenerateProg := '<------===== POMS Essence Miner Progress Report =====------>' + Chr(10);
  if (UseReflection) then
    GenerateProg := GenerateProg + '<------=====          Using Reflection Methods          =====------>' + Chr(10);
  GenerateProg := GenerateProg + '           Script run # ' + IntToStr(TotalScript[0]) + ' - ' + TheDate(1) + ' - ' + TheTime + '.' + Chr(10);
  GenerateProg := GenerateProg + '  Total run time:                        ' + TimeRunning + Chr(10);
  GenerateProg := GenerateProg + '  Total essence mined:                   ' + IntToStr(Total[0]) + Chr(10);
  GenerateProg := GenerateProg + '  Total essence using script mined:      ' + IntToStr(TotalScript[1]) + Chr(10);
  GenerateProg := GenerateProg + '  Avg. total ess per a script run:       ' + IntToStr(Round(TotalScript[1]div TotalScript[0])) + Chr(10);
  GenerateProg := GenerateProg + '  Essence per hour:                      ' + IntToStr(Round((3600 * (Total[0])) div (TCounter))) + Chr(10);
  GenerateProg := GenerateProg + '  Total trips made:                      ' + IntToStr(Total[2]) + Chr(10);
  GenerateProg := GenerateProg + '  Total trips using script made:         ' + IntToStr(TotalScript[3]) + Chr(10);
  GenerateProg := GenerateProg + '  Avg. total trips made per script run:  ' + IntToStr(Round(TotalScript[3]div TotalScript[0])) + Chr(10);
  GenerateProg := GenerateProg + '  Trips per hour:                        ' + IntToStr(Round((3600 * (Total[2])) div (TCounter))) + Chr(10);
  GenerateProg := GenerateProg + '  Total banks:                           ' + IntToStr(Total[3]) + Chr(10);
  GenerateProg := GenerateProg + '  Total banks using script:              ' + IntToStr(TotalScript[4]) + Chr(10);
  GenerateProg := GenerateProg + '  Avg. total banks per script run:       ' + IntToStr(Round(TotalScript[4]div TotalScript[0])) + Chr(10);
  GenerateProg := GenerateProg + '  Banks per hour:                        ' + IntToStr(Round((3600 * (Total[3])) div (TCounter))) + Chr(10);
  GenerateProg := GenerateProg + '  Total Mining EXP gained:               ' + FloatToStr(Total[1]) + Chr(10);
  GenerateProg := GenerateProg + '  Total Mining EXP gained using script:  ' + FloatToStr(TotalScript[2]) + Chr(10);
  GenerateProg := GenerateProg + '  Avg. Mining EXP gained per script run: ' + IntToStr(Round(TotalScript[2]div TotalScript[0])) + Chr(10);
  GenerateProg := GenerateProg + '  Mining EXP per hour:                   ' + IntToStr(Round((3600 * (Total[1])) div (TCounter))) + Chr(10);
  if (TotalScript[5] > 0) then
  begin
    GenerateProg := GenerateProg + '  Total randoms found:                   ' + IntToStr(Total[4]) + Chr(10);
    GenerateProg := GenerateProg + '  Total randoms found using script:      ' + IntToStr(TotalScript[5]) + Chr(10);
    GenerateProg := GenerateProg + '  Avg. randoms found per script run:     ' + IntToStr(Round(TotalScript[5] div TotalScript[0])) + Chr(10);
  end;
  GenerateProg := GenerateProg + '[ ----------------------------------------------------------------------- ]' + Chr(10);
  GenerateProg := GenerateProg + '' + Chr(10);
  GenerateProg := GenerateProg + '<------===== POMS Essence Miner Player''s Report =====------>' + Chr(10);
  for I := 0 to (HowManyPlayers - 1) do
  begin
    PlayerRand := '' + Chr(10);
    PlayerRands := '' + Chr(10);
    if (Players[I].Active) then
      WeAreActive := '  (Active)  -- Ess: '
    else
      WeAreActive := ' (InActive) -- Ess: ';
    if (not (Players[I].Rand = '')) then
      PlayerRand := ' -- Rand: ' + Players[I].Rand;
    if (Players[I].Integers[6] > 0) then
      PlayerRands := ' -- Randoms: ' + IntToStr(Players[I].Integers[6]);
    GenerateProg := GenerateProg + '  ' + '**-**' + WeAreActive + IntToStr(Players[I].Integers[2]) + ' -- Trips: ' + IntToStr(Players[I].Integers[4]) + ' -- Loc: ' + Players[I].Loc + ' -- EXP: ' + IntToStr(Players[I].Integers[3]) + Chr(10);
    GenerateProg := GenerateProg + '  ' + ' -- Banks: ' + IntToStr(Players[I].Banked) + ' -- Mining Level: ' + IntToStr(Players[I].Level[15]) + PlayerRands + PlayerRand + Chr(10);
  end;
  GenerateProg := GenerateProg + '[ ----------------------------------------------------------------------- ]' + Chr(10);}
  WriteLn('Displayed progress report.');
  {$IFDEF POMS_DEBUG}
  if (not DebugKill) then
  begin
    POMS_VARIABLES := ['Time Running: ' + TimeRunning,
    'Essence Mined: ' + IntToStr(Total[0]),
    'Essence PdivH: ' + IntToStr(Round((3600 * (Total[0])) div (TCounter))),
    'Trips Made: ' + IntToStr(Total[2]),
    'Trips PdivH: ' + IntToStr(Round((3600 * (Total[2])) div (TCounter))),
    'Mining EXP Gained: ' + FloatToStr(Total[1]),
    'Mining EXP PdivH: ' + IntToStr(Round((3600 * (Total[1])) div (TCounter)))];
  end;
  {$ENDIF}
  ClearTPA;
  if (TakeBreaks) then
    if (Total[2] > 0) then
      if ((Total[2] mod TakeBreaksEvery) = 0) then
      begin
        T := GetSystemTime;
        WriteLn(TheTime + ' Taking a break for ' + IntToStr(BreakFor) + ' minute(s)...');
        LI := LoggedIn;
        if (LI) then
        begin
          CloseBank;
          LogOut;
        end;
        Sleep(BreakFor * 60000);
        WriteLn('Done breaking.');
        if (LI) then
          InitPlayer;
        IncEx(TimeStarted, GetSystemTime - T);
      end;
end;

{*******************************************************************************
                                 MAIN LOOP
*******************************************************************************}

{*******************************************************************************
procedure MainLoop;
Description: This is the main loop, I created it in a procedure to avoid the use
of global variables.
*******************************************************************************}

procedure MainLoop;
var
  IndividualLoads: LongInt;
begin
  ScriptSettingsPath := ScriptPath + 'POMSEMScriptSettings.DAT';
  PlayerSettingsPath := ScriptPath + 'POMSEMPlayerSettings.DAT';
  StartUpScript;
  {$IFDEF Reflection}
    SetupRRL;
  {$ENDIF}
  repeat
    IndividualLoads := 0;
    InitPlayer;
    repeat
      case (Between('(', ')', Players[CurrentPlayer].Strings[1])) of
        'VEB': begin
                 WalkToShop;
                 TeleportAubury;
                 MineEssence;
                 WalkToBank;
               end;
      end;
      POMSEMBanking;
      if (LoggedIn) then
      begin
        Inc(Players[CurrentPlayer].Integers[4]);
        Inc(IndividualLoads);
        Inc(TotalScript[3]);
        WriteINI('TotalScript', '3', IntToStr(TotalScript[3]), ScriptSettingsPath);
        Inc(Total[2]);
      end;
      if ((Players[CurrentPlayer].Integers[2] >= Players[CurrentPlayer].Integers[1]) and (LoggedIn)) then
      begin
        Players[CurrentPlayer].Loc := 'Finished!';
        Players[CurrentPlayer].Active := False;
        CloseBank;
        Wait(500 + Random(500));
        LogOut;
      end;
      ProgressReport;
    until ((IndividualLoads >= Players[CurrentPlayer].Integers[0]) or (not (LoggedIn)));
    CloseBank;
    NextPlayer(LoggedIn);
  until (AllPlayersInActive);
  WriteLn('All players exhausted.');
  TerminateScript;
end;

begin
  MainLoop;
end.