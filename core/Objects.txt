{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
RRL - Reflection Resource Library
Object routines.

---------------------------------------------------------

 * function r_GetObjectInteractableAt(const TT: TRSTile): TRSObject;
     By: Timer
 * function r_GetObjectAt(const T: TRSTile; const ObjType: Integer): TRSObject;
     By: Timer
 * function r_GetAllObjectsByType(const ObjType: Integer): array of TRSObject;
     By: Timer
 * function r_GetAllObjectsByID(const ID, ObjType: Integer): array of TRSObject;
     By: Timer
 * function r_GetAllObjectsByTypeOptimized(const ObjType, TileRadius: Integer): array of TRSObject;
     By: Timer
 * function r_GetAllObjectsByIDOptimized(const ID, ObjType, TileRadius: Integer): array of TRSObject;
     By: Timer
 * function r_SortObjects(const Arr: array of TRSObject; const From: TRSTile): array of TRSObject;
     By: Timer
 * function r_GetClosestObjectByID(const ID, ObjType: Integer): TRSObject;
     By: Timer
 * function r_GetClosestObjectByIDOptimized(const ID, ObjType, TileRadius: Integer): TRSObject;
     By: Timer
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{
This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

Copyright (C) 2010 - 2011 by Joe Haddad, all rights reserved.
This file is part of the RRL project (https://github.com/Timer/RRL).

For extended permissions please contact me by E-Mail, Timer150@Gmail.com.
}

const
  R_OBJECT_TYPE_INTERACTABLE = 1;
  R_OBJECT_TYPE_WALL_OBJECT = 2;
  R_OBJCET_TYPE_WALL_DECORATION = 3;
  R_OBJECT_TYPE_FLOOR_DECORATION = 4;

function NULL_RSOBJECT: TRSObject;
begin
  with Result do
  begin
    ID := -1;
    ObjectType := -1;
    Tile := NULL_RSTILE;
    MainTile := NULL_RSTILE;
    Area := IntToBox(-1, -1, -1, -1);
  end;
end;

function r_GetObjectInteractableAt(const TT: TRSTile): TRSObject;
var
  BaseX, BaseY, Plane, ObjID: Integer;
  T, ObjRTile: TRSTile;
  Ground, Node, Last, Obj, Obj2: LongInt;
  ObjArea: TArea;
begin
  Result := NULL_RSOBJECT;
  try
    BaseX := SmartGetFieldInt(0, hook_BaseX);
    BaseY := SmartGetFieldInt(0, hook_BaseY);
    T := RSTile(TT.x - BaseX, TT.y - BaseY);
    Plane := SmartGetFieldInt(0, hook_Current_Plane);
    Ground := SmartGetFieldArray3DObject(0, hook_GroundTiles, Plane, T.x, T.y);
    Node := SmartGetFieldObject(Ground, hook_Ground_Animables);
    while (Node <> 0) do
    begin
      Obj := SmartGetFieldObject(Node, hook_Animable_Get);
      if (Obj <> 0) then
      begin
        ObjID := SmartGetFieldShort(Obj, hook_Object_Interactive_ID) and $FFFF;
        ObjArea.x1 := (BaseX + SmartGetFieldShort(Obj, hook_Animable_GetAreaX1));
        ObjArea.y1 := (BaseY + SmartGetFieldShort(Obj, hook_Animable_GetAreaY1));
        ObjArea.x2 := (BaseX + SmartGetFieldShort(Obj, hook_Animable_GetAreaX2));
        ObjArea.y2 := (BaseY + SmartGetFieldShort(Obj, hook_Animable_GetAreaY2));
        ObjRTile.x := Round(BaseX + (SmartGetFieldInt(Obj, hook_LocalX) div 512));
        ObjRTile.y := Round(BaseY + (SmartGetFieldInt(Obj, hook_LocalY) div 512));
        if (ObjID = -1) or (ObjID = 65535) then
        begin
          Obj2 := SmartGetFieldObject(Obj, hook_Object_Interactive2_Obj);
          if (Obj2 <> 0) then
          begin
            ObjID := SmartGetFieldShort(Obj2, hook_Object_Interactive2_ID) and $FFFF;
            if (ObjID = -1) or (ObjID = 65535) then
              Break;
            ObjArea.x1 := (BaseX + SmartGetFieldShort(Obj2, hook_Animable_GetAreaX1));
            ObjArea.y1 := (BaseY + SmartGetFieldShort(Obj2, hook_Animable_GetAreaY1));
            ObjArea.x2 := (BaseX + SmartGetFieldShort(Obj2, hook_Animable_GetAreaX2));
            ObjArea.y2 := (BaseY + SmartGetFieldShort(Obj2, hook_Animable_GetAreaY2));
            ObjRTile.x := Round(BaseX + (SmartGetFieldInt(Obj2, hook_LocalX) div 512));
            ObjRTile.y := Round(BaseY + (SmartGetFieldInt(Obj2, hook_LocalY) div 512));
          end;
          SmartFreeObject(Obj2);
        end;
        Result := RSObject(ObjID, R_OBJECT_TYPE_INTERACTABLE, TT, ObjRTile, ObjArea);
        SmartFreeObject(Obj);
        Break;
      end;
      SmartFreeObject(Obj);
      Last := Node;
      SmartFreeObject(Node);
      Node := SmartGetFieldObject(Last, hook_Animable_Next);
    end;
  finally
    try
      SmartFreeObject(Node);
    except
    end;
    try
      SmartFreeObject(Ground);
    except
    end;
    try
      SmartFreeObject(Obj);
    except
    end;
    try
      SmartFreeObject(Obj2);
    except
    end;
    try
      SmartFreeObject(Last);
    except
    end;
  end;
end;

function r_GetObjectAt(const T: TRSTile; const ObjType: Integer): TRSObject;
begin
  Result := NULL_RSOBJECT;
  case (ObjType) of
    R_OBJECT_TYPE_INTERACTABLE: Result := r_GetObjectInteractableAt(T);
  end;
end;

function r_GetAllObjectsByType(const ObjType: Integer): array of TRSObject;
var
  C, BaseX, BaseY, x, y: Integer;
  Obj: TRSObject;
begin
  Result := [];
  BaseX := SmartGetFieldInt(0, hook_BaseX);
  BaseY := SmartGetFieldInt(0, hook_BaseY);
  SetLength(Result, 10816);
  for x := BaseX to (BaseX + 104) do
    for y := BaseY to (BaseY + 104) do
    begin
      Obj := r_GetObjectAt(RSTile(x, y), ObjType);
      if (not (Obj = NULL_RSOBJECT)) then
      begin
        Result[C] := Obj;
        Inc(C);
      end;
    end;
  SetLength(Result, C);
end;

function r_GetAllObjectsByID(const ID, ObjType: Integer): array of TRSObject;
var
  C, BaseX, BaseY, x, y: Integer;
  Obj: TRSObject;
begin
  Result := [];
  BaseX := SmartGetFieldInt(0, hook_BaseX);
  BaseY := SmartGetFieldInt(0, hook_BaseY);
  SetLength(Result, 10816);
  for x := BaseX to (BaseX + 104) do
    for y := BaseY to (BaseY + 104) do
    begin
      Obj := r_GetObjectAt(RSTile(x, y), ObjType);
      if (not (Obj = NULL_RSOBJECT)) and (Obj.ID = ID) then
      begin
        Result[C] := Obj;
        Inc(C);
      end;
    end;
  SetLength(Result, C);
end;

function r_GetAllObjectsByTypeOptimized(const ObjType, TileRadius: Integer): array of TRSObject;
var
  C, BaseX, BaseY, x, y, xMi, yMi, xMa, yMa: Integer;
  Obj: TRSObject;
  OurLoc: TRSTile;
begin
  Result := [];
  BaseX := SmartGetFieldInt(0, hook_BaseX);
  BaseY := SmartGetFieldInt(0, hook_BaseY);
  OurLoc := r_GetLocation;
  xMi := OurLoc.x - TileRadius;
  yMi := OurLoc.y - TileRadius;
  xMa := OurLoc.x + TileRadius;
  yMa := OurLoc.y + TileRadius;
  if (xMi < BaseX) then
    xMi := BaseX;
  if (yMi < BaseY) then
    yMi := BaseY;
  if (xMa > BaseX + 104) then
    xMa := BaseX + 104;
  if (yMa > BaseY + 104) then
    yMa := BaseY + 104;
  SetLength(Result, (yMa - yMi) * (xMa - xMi));
  for x := xMi to xMa do
    for y := yMi to yMa do
    begin
      Obj := r_GetObjectAt(RSTile(x, y), ObjType);
      if (not (Obj = NULL_RSOBJECT)) then
      begin
        Result[C] := Obj;
        Inc(C);
      end;
    end;
  SetLength(Result, C);
end;

function r_GetAllObjectsByIDOptimized(const ID, ObjType, TileRadius: Integer): array of TRSObject;
var
  C, BaseX, BaseY, x, y, xMi, yMi, xMa, yMa: Integer;
  Obj: TRSObject;
  OurLoc: TRSTile;
begin
  Result := [];
  BaseX := SmartGetFieldInt(0, hook_BaseX);
  BaseY := SmartGetFieldInt(0, hook_BaseY);
  OurLoc := r_GetLocation;
  xMi := OurLoc.x - TileRadius;
  yMi := OurLoc.y - TileRadius;
  xMa := OurLoc.x + TileRadius;
  yMa := OurLoc.y + TileRadius;
  if (xMi < BaseX) then
    xMi := BaseX;
  if (yMi < BaseY) then
    yMi := BaseY;
  if (xMa > BaseX + 104) then
    xMa := BaseX + 104;
  if (yMa > BaseY + 104) then
    yMa := BaseY + 104;
  SetLength(Result, (yMa - yMi) * (xMa - xMi));
  for x := xMi to xMa do
    for y := yMi to yMa do
    begin
      Obj := r_GetObjectAt(RSTile(x, y), ObjType);
      if (not (Obj = NULL_RSOBJECT)) and (Obj.ID = ID) then
      begin
        Result[C] := Obj;
        Inc(C);
      end;
    end;
  SetLength(Result, C);
end;

function r_SortObjects(const Arr: array of TRSObject; const From: TRSTile): array of TRSObject;
var
  i, ii, L: LongInt;
  TPA: TPointArray;
begin
  L := Length(Arr);
  if (L < 1) then
    Exit;
  SetLength(Result, L);
  SetLength(TPA, L);
  for i := 0 to L - 1 do
    TPA[i] := Point(Arr[i].Tile.x, Arr[i].Tile.y);
  SortTPAFrom(TPA, Point(From.x, From.y));
  for i := 0 to L - 1 do
    for ii := 0 to L - 1 do
      if (TPA[i].x = Arr[ii].Tile.x) and (TPA[i].y = Arr[ii].Tile.y) then
      begin
        Result[i] := Arr[ii];
        Break;
      end;
end;

function r_GetClosestObjectByID(const ID, ObjType: Integer): TRSObject;
var
  Arr: array of TRSObject;
begin
  Arr := r_SortObjects(r_GetAllObjectsByID(ID, ObjType), r_GetLocation);
  if (Length(Arr) > 0) then
    Result := Arr[0];
end;

function r_GetClosestObjectByIDOptimized(const ID, ObjType, TileRadius: Integer): TRSObject;
var
  Arr: array of TRSObject;
begin
  Arr := r_SortObjects(r_GetAllObjectsByIDOptimized(ID, ObjType, TileRadius), r_GetLocation);
  if (Length(Arr) > 0) then
    Result := Arr[0];
end;