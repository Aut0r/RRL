{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
RRL - Reflection Resource Library
Calulation core file

---------------------------------------------------------

 * function r_TileToMinimap(const Tile: TRSTile): TPoint;
     By: Timer
 * function r_TileOnMinimapEx(const CheckTile: TRSTile; const Dist: Integer): Boolean;
     By: Timer
 * function r_TileOnMinimap(const CheckTile: TRSTile): Boolean;
     By: Timer
 * function r_DistanceBetween(const StartLocation, EndLocation: TRSTile): Extended;
     By: Timer
 * function r_PointOnScreen(const p: TPoint): Boolean;
     By: Timer
 * function r_GetTileHeight(const t: TRSTile): Extended;
     By: Timer
 * function r_MatrixDataToScreen(const mX, mY, mZ: Extended): TPoint;
     By: Timer
 * function r_WorldToScreen(const x, y, z: Extended): TPoint;
     By: Timer
 * function r_TileToScreenExEx(const t: TRSTile; const h: Extended; const O: TRSTilePosition): TPoint;
     By: Timer
 * function r_TileToScreenEx(const t: TRSTile; const h: Extended): TPoint;
     By: Timer
 * function r_TileToScreen(const t: TRSTile): TPoint;
     By: Timer
 * function r_TileOnScreenEx(const t: TRSTile; const h: Extended): Boolean;
     By: Timer
 * function r_TileOnScreen(const t: TRSTile): Boolean;
     By: Timer
 * function r_SortTilesEx(const Arr: TRSTileArray; const From: TRSTile): TRSTileArray;
     By: Timer
 * function r_SortTiles(const Arr: TRSTileArray): TRSTileArray;
     By: Timer
 * function r_GetClosestTile(const Arr: TRSTileArray): TRSTile;
    By: Timer
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{
This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

Copyright (C) 2010 - 2011 by Joe Haddad, all rights reserved.
This file is part of the RRL project (https://github.com/Timer/RRL).

For extended permissions please contact me by E-Mail, Timer150@Gmail.com.
}

function NULL_RSTILE: TRSTile; forward;

function r_TileToMinimap(const Tile: TRSTile): TPoint;
var
  RadiansAngle: Extended;
  TempX, TempY: Integer;
  OurLocation: TRSTile;
begin
  OurLocation := r_GetLocation;
  RadiansAngle := r_GetMinimapAngleRadians;
  TempX := (Tile.x - OurLocation.x) * 4 - 2;
  TempY := (OurLocation.y - Tile.y) * 4 - 2;
  Result := Point(
                  Round(TempX * Cos(RadiansAngle) + TempY * Sin(RadiansAngle)) + 628,
                  Round(TempY * Cos(RadiansAngle) - TempX * Sin(RadiansAngle)) + 87
                  );
end;

function r_TileOnMinimapEx(const CheckTile: TRSTile; const Dist: Integer): Boolean;
var
  OurLocation: TRSTile;
begin
  OurLocation := r_GetLocation;
  {$IFDEF SIMBA}
    Result := Sqrt(Sqr(CheckTile.x - OurLocation.x) + Sqr(CheckTile.y - OurLocation.y)) <= Dist;
  {$ELSE}
    Result := InCircle(CheckTile.x, CheckTile.y, OurLocation.x, OurLocation.y, Dist);
  {$ENDIF}
end;

function r_TileOnMinimap(const CheckTile: TRSTile): Boolean;
begin
  Result := r_TileOnMinimapEx(CheckTile, 17);
end;

function r_DistanceBetween(const StartLocation, EndLocation: TRSTile): Extended;
begin
  Result := Sqrt(((StartLocation.X - EndLocation.X) *
                 (StartLocation.X - EndLocation.X)) +
                 ((StartLocation.Y - EndLocation.Y) *
                 (StartLocation.Y - EndLocation.Y)));
end;

function r_PointOnScreen(const p: TPoint): Boolean;
begin
  Result := PointInBox(p, IntToBox(4, 4, 515, 337));
end;

function r_GetTileHeight(const t: TRSTile): Extended;
var
  x, y, CurrentPlane: Integer;
  PathToPlane: LongInt;
begin
  Result := -1;
  x := t.x - SmartGetFieldInt(0, hook_BaseX);
  y := t.y - SmartGetFieldInt(0, hook_BaseY);
  if (x < 0) or (x > 104) or (y < 0) or (y > 104) then
    Exit;
  CurrentPlane := SmartGetFieldInt(0, hook_Current_Plane);
  if (CurrentPlane < 3) and ((SmartGetFieldArray3DByte(0, hook_GroundSettings_Array, 1, x, y) and 2) <> 0) then
    Inc(CurrentPlane);
  PathToPlane := SmartGetFieldArrayObject(0, hook_Plane_Array, CurrentPlane);
  Result := (SmartGetFieldArray2DInt(PathToPlane, hook_Tile_Heights, x, y) +
             SmartGetFieldArray2DInt(PathToPlane, hook_Tile_Heights, x, y + 1) +
             SmartGetFieldArray2DInt(PathToPlane, hook_Tile_Heights, x + 1, y) +
             SmartGetFieldArray2DInt(PathToPlane, hook_Tile_Heights, x + 1, y + 1)) / 4;
  SmartFreeObject(PathToPlane);
end;

function r_MatrixDataToScreen(const mX, mY, mZ: Extended): TPoint;
var
  RD: TRenderData;
  R: TRender;
  x, y, z: Extended;
  l: LongInt;
  NULL_TPOINT: TPoint;
  Tries: Byte;
begin
  NULL_TPOINT := Point(-1, -1);
  Result := NULL_TPOINT;
  l := GetSystemTime;
  while (Tries <= 10) and (Result = NULL_TPOINT) do
  begin
    r_DeleteRenderMatrix(RD, R);
    r_FetchRenderMatrix(RD, R);
    z := RD.zOffset + (RD.zX * mX + RD.zY * mY + RD.zZ * mZ);
    if (z < R.zMin) or (z > R.zMax) then
      Exit;
    x := R.xScale * (RD.xOffset + (RD.xX * mX + RD.xY * mY + RD.xZ * mZ)) / z;
    y := R.yScale * (RD.yOffset + (RD.yX * mX + RD.yY * mY + RD.yZ * mZ)) / z;
    if (x >= R.xMin) and (x <= R.xMax) and (y >= R.yMin) and (y <= R.yMax) then
    begin
      Result.x := Round((x - R.xMin) + 4);
      Result.y := Round((y - R.yMin) + 4);
    end else
      Inc(Tries);
  end;
end;

function r_WorldToScreen(const x, y, z: Extended): TPoint;
var
  NULL_TPOINT: TPoint;
begin
  NULL_TPOINT := Point(-1, -1);
  Result := r_MatrixDataToScreen(x, y, z);
  if (not r_PointOnScreen(Result)) then
    Result := NULL_TPOINT;
end;

function r_TileToScreenExEx(const t: TRSTile; const h: Extended; const O: TRSTilePosition): TPoint;
var
  x, y, z: Extended;
begin
  x := 512.0 * (t.x - SmartGetFieldInt(0, hook_BaseX) + O.xOffset);
  y := r_GetTileHeight(t) - h;
  z := 512.0 * (t.y - SmartGetFieldInt(0, hook_BaseY) + O.yOffset);
  Result := r_WorldToScreen(x, y, z);
end;

function r_TileToScreenEx(const t: TRSTile; const h: Extended): TPoint;
begin
  Result := r_TileToScreenExEx(t, h, R_TILE_POSITION_CENTER);
end;

function r_TileToScreen(const t: TRSTile): TPoint;
begin
  Result := r_TileToScreenEx(t, 0);
end;

function r_TileOnScreenEx(const t: TRSTile; const h: Extended): Boolean;
begin
  Result := r_PointOnScreen(r_TileToScreenEx(t, h));
end;

function r_TileOnScreen(const t: TRSTile): Boolean;
begin
  Result := r_PointOnScreen(r_TileToScreenEx(t, 0));
end;

function r_SortTilesEx(const Arr: TRSTileArray; const From: TRSTile): TRSTileArray;
var
  TPA: TPointArray;
  i, ii, l: Integer;
begin
  l := Length(Arr);
  if (l > 0) then
  begin
    SetLength(TPA, l);
    SetLength(Result, l);
    for i := 0 to l - 1 do
      TPA[i] := Point(Arr[i].x, Arr[i].y);
    SortTPAFrom(TPA, Point(From.x, From.y));
    for i := 0 to l - 1 do
      for ii := 0 to l - 1 do
        if (TPA[i].x = Arr[ii].x) and (TPA[i].y = Arr[ii].y) then
        begin
          Result[i] := Arr[ii];
          Break;
        end;
  end else
    Result := Arr;
end;

function r_SortTiles(const Arr: TRSTileArray): TRSTileArray;
begin
  Result := r_SortTilesEx(Arr, r_GetLocation);
end;

function r_GetClosestTile(const Arr: TRSTileArray): TRSTile;
var
  Arr2: TRSTileArray;
begin
  Result := NULL_RSTILE;
  if (Length(Arr) > 0) then
  begin
    Arr2 := r_SortTiles(Arr);
    Result := Arr2[0];
  end;
end;