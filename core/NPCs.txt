{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
RRL - Reflection Resource Library
NPC routines.

---------------------------------------------------------

 * function r_GetAllNPCs: TNPCArray;
     By: Timer
 * function r_GetAllNPCsByIDEx(const IDs: TIntegerArray): TNPCArray;
     By: Timer
 * function r_GetAllNPCsByID(const ID: Integer): TNPCArray;
     By: Timer
 * function r_SortNPCs(const Arr: array of TNPC; const From: TRSTile): array of TNPC;
     By: Timer
 * function r_GetClosestNPCByIDEx(const IDs: TIntegerArray): TNPC;
     By: Timer
 * function r_GetClosestNPCByID(const ID: Integer): TNPC;
     By: Timer
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{
This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

Copyright (C) 2010 - 2011 by Joe Haddad, all rights reserved.
This file is part of the RRL project (https://github.com/Timer/RRL).

For extended permissions please contact me by E-Mail, Timer150@Gmail.com.
}

function NULL_NPC: TNPC;
begin
  with Result do
  begin
   Index := -1;
   ID := -1;
   Level := -1;
   Animation := -1;
   Orientation := -1;
   HPRatio := -1;
   Height := -1.0;
   Interacting := -1;
   Name := '';
   Moving := False;
   Fighting := False;
   Tile := NULL_RSTILE;
  end;
end;

function r_GetAllNPCs: TNPCArray;
var
  NumberOfNPCs, i, C, BaseX, BaseY, h: Integer;
  PathToNPCNode, PathToNPC, PathToNPCDefinition, JavaName: LongInt;
begin
  NumberOfNPCs := SmartGetFieldInt(0, r_Hooks[hook_NPCCount]);
  if (NumberOfNPCs < 1) then
    Exit;
  SetLength(Result, NumberOfNPCs);
  h := NumberOfNPCs - 1;//Simba compatibility.
  for i := 0 to h do
    try
      PathToNPCNode := SmartGetFieldArrayObject(0, r_Hooks[hook_NPCNodes], i);
      PathToNPC := SmartGetFieldObject(PathToNPCNode, r_Hooks[hook_NPCNode_NPC]);
      PathToNPCDefinition := SmartGetFieldObject(PathToNPC, r_Hooks[hook_NPC_Definition]);
      JavaName := SmartGetFieldObject(PathToNPCDefinition, r_Hooks[hook_NPCDefinition_Name]);
      if (Lowercase(Trim(r_GetString(JavaName))) = 'null') then
      begin
        try
          SmartFreeObject(PathToNPCNode);
        except
        end;
        try
          SmartFreeObject(PathToNPC);
        except
        end;
        try
          SmartFreeObject(PathToNPCDefinition);
        except
        end;
        try
          SmartFreeObject(JavaName);
        except
        end;
        Continue;
      end;
      with Result[C] do
      begin
        Index := SmartGetFieldArrayInt(0, r_Hooks[hook_NPCIndexes], i);
        ID := SmartGetFieldInt(PathToNPCDefinition, r_Hooks[hook_NPCDefinition_ID]);
        Name := r_GetString(JavaName);
        BaseX := SmartGetFieldInt(0, r_Hooks[hook_BaseX]);
        BaseY := SmartGetFieldInt(0, r_Hooks[hook_BaseY]);
        Tile.x := BaseX + SmartGetFieldInt(PathToNPC, r_Hooks[hook_Animable_X]) div 512;
        Tile.y := BaseY + SmartGetFieldInt(PathToNPC, r_Hooks[hook_Animable_Y]) div 512;
        Moving := r_GetCharacterMovement(PathToNPC, False) > 0;
        Fighting := r_GetCharacterFighting(PathToNPC, False);
        Animation := r_GetCharacterAnimation(PathToNPC, False);
        Height := r_GetCharacterHeight(PathToNPC, False);
        HPRatio := r_GetCharacterHPRatio(PathToNPC, False);
        Orientation := r_GetCharacterOrientation(PathToNPC, False);
        Level := r_GetCharacterLevel(PathToNPC, False);
        Interacting := r_GetCharacterInteracting(PathToNPC, False);
      end;
      Inc(C);
    finally
      try
        SmartFreeObject(PathToNPCNode);
      except
      end;
      try
        SmartFreeObject(PathToNPC);
      except
      end;
      try
        SmartFreeObject(PathToNPCDefinition);
      except
      end;
      try
        SmartFreeObject(JavaName);
      except
      end;
    end;
  SetLength(Result, C);
end;

function r_GetAllNPCsByIDEx(const IDs: TIntegerArray): TNPCArray;
var
  NPCArray: TNPCArray;
  i, l, C, ii, ll: Integer;
begin
  NPCArray := r_GetAllNPCs;
  l := Length(NPCArray);
  ll := Length(IDs);
  SetLength(Result, l);
  for i := 0 to l - 1 do
    for ii := 0 to ll - 1 do
      if (NPCArray[i].ID = IDs[ii]) then
      begin
        Result[C] := NPCArray[i];
        Inc(C);
        Break;
      end;
  SetLength(Result, C);
end;

function r_GetAllNPCsByID(const ID: Integer): TNPCArray;
begin
  Result := r_GetAllNPCsByIDEx([ID]);
end;

function r_SortNPCs(const Arr: array of TNPC; const From: TRSTile): array of TNPC;
var
  i, ii, L: LongInt;
  TPA: TPointArray;
begin
  L := Length(Arr);
  if (L < 1) then
    Exit;
  SetLength(Result, L);
  SetLength(TPA, L);
  for i := 0 to L - 1 do
    TPA[i] := Point(Arr[i].Tile.x, Arr[i].Tile.y);
  SortTPAFrom(TPA, Point(From.x, From.y));
  for i := 0 to L - 1 do
    for ii := 0 to L - 1 do
      if (TPA[i].x = Arr[ii].Tile.x) and (TPA[i].y = Arr[ii].Tile.y) then
      begin
        Result[i] := Arr[ii];
        Break;
      end;
end;

function r_GetClosestNPCByIDEx(const IDs: TIntegerArray): TNPC;
var
  NPCArray, OurNPCs: TNPCArray;
  C: Integer;
begin
  Result := NULL_NPC;
  NPCArray := r_GetAllNPCsByIDEx(IDs);
  SetLength(OurNPCs, C);
  OurNPCs := r_SortNPCs(NPCArray, r_GetLocation);
  if (Length(OurNPCs) > 0) then
    Result := OurNPCs[0];
end;

function r_GetClosestNPCByID(const ID: Integer): TNPC;
begin
  Result := r_GetClosestNPCByIDEx([ID]);
end;