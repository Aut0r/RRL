{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
RRL - Reflection Resource Library
NPC routines.

---------------------------------------------------------

 * function GetNPCs: TNPCArray;
     By: Timer
 * function GetNPCsByIDEx(const IDs: TIntegerArray): TNPCArray;
     By: Timer
 * function GetNPCsByID(const ID: Integer): TNPCArray;
     By: Timer
 * function SortNPCs(const Arr: array of TNPC; const From: TRSTile): array of TNPC;
     By: Timer
 * function GetClosestNPCByIDEx(const IDs: TIntegerArray): TNPC;
     By: Timer
 * function GetClosestNPCByID(const ID: Integer): TNPC;
     By: Timer
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{
This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

Copyright (C) 2010 - 2011 by Joe Haddad, all rights reserved.
This file is part of the RRL project (https://github.com/Timer/RRL).

For extended permissions please contact me by E-Mail, Timer150@Gmail.com.
}

function NULL_NPC: TNPC;
begin
  with Result do
  begin
   Index := -1;
   ID := -1;
   Level := -1;
   Animation := -1;
   Orientation := -1;
   HPRatio := -1;
   Height := -1.0;
   Interacting := -1;
   Name := '';
   Moving := False;
   Fighting := False;
   Tile := NULL_RSTILE;
  end;
end;

function GetNPCs: TNPCArray;
var
  NumberOfNPCs, i, C, BaseX, BaseY: Integer;
  PathToNPCNode, PathToNPC, PathToNPCDefinition, JavaName: LongInt;
begin
  NumberOfNPCs := SmartGetFieldInt(0, hook_NPC_Count);
  if (NumberOfNPCs < 1) then
    Exit;
  SetLength(Result, NumberOfNPCs);
  for i := 0 to NumberOfNPCs - 1 do
    try
      with Result[C] do
      begin
        Index := SmartGetFieldArrayInt(0, hook_NPC_Index_Array, i);
        PathToNPCNode := SmartGetFieldArrayObject(0, hook_NPC_Node_Array, i);
        PathToNPC := SmartGetFieldObject(PathToNPCNode, hook_Node_GetNPC);
        PathToNPCDefinition := SmartGetFieldObject(PathToNPC, hook_NPC_Definition);
        JavaName := SmartGetFieldObject(PathToNPCDefinition, hook_NPC_Definition_Name);
        if (Lowercase(Trim(GetString(JavaName))) = 'null') then
        begin
          try
            SmartFreeObject(PathToNPCNode);
          except
          end;
          try
            SmartFreeObject(PathToNPC);
          except
          end;
          try
            SmartFreeObject(PathToNPCDefinition);
          except
          end;
          try
            SmartFreeObject(JavaName);
          except
          end;
          Continue;
        end;
        ID := SmartGetFieldInt(PathToNPCDefinition, hook_NPC_ID);
        Name := GetString(JavaName);
        BaseX := SmartGetFieldInt(0, hook_BaseX);
        BaseY := SmartGetFieldInt(0, hook_BaseY);
        Tile.x := BaseX + SmartGetFieldInt(PathToNPC, hook_LocalX) div 512;
        Tile.y := BaseY + SmartGetFieldInt(PathToNPC, hook_LocalY) div 512;
        Moving := GetCharacterMovement(PathToNPC, False) > 0;
        Fighting := GetCharacterFighting(PathToNPC, False);
        Animation := GetCharacterAnimation(PathToNPC, False);
        Height := GetCharacterHeight(PathToNPC, False);
        HPRatio := GetCharacterHPRatio(PathToNPC, False);
        Orientation := GetCharacterOrientation(PathToNPC, False);
        Level := GetCharacterLevel(PathToNPC, False);
        Interacting := GetCharacterInteracting(PathToNPC, False);
      end;
      Inc(C);
    finally
      try
        SmartFreeObject(PathToNPCNode);
      except
      end;
      try
        SmartFreeObject(PathToNPC);
      except
      end;
      try
        SmartFreeObject(PathToNPCDefinition);
      except
      end;
      try
        SmartFreeObject(JavaName);
      except
      end;
    end;
  SetLength(Result, C);
end;

function GetNPCsByIDEx(const IDs: TIntegerArray): TNPCArray;
var
  NPCArray: TNPCArray;
  i, l, C, ii, ll: Integer;
begin
  NPCArray := GetNPCs;
  l := Length(NPCArray);
  ll := Length(IDs);
  SetLength(Result, l);
  for i := 0 to l - 1 do
    for ii := 0 to ll - 1 do
      if (NPCArray[i].ID = IDs[ii]) then
      begin
        Result[C] := NPCArray[i];
        Inc(C);
        Break;
      end;
  SetLength(Result, C);
end;

function GetNPCsByID(const ID: Integer): TNPCArray;
begin
  Result := GetNPCsByIDEx([ID]);
end;

function SortNPCs(const Arr: array of TNPC; const From: TRSTile): array of TNPC;
var
  i, ii, L: LongInt;
  TPA: TPointArray;
begin
  L := Length(Arr);
  if (L < 1) then
    Exit;
  SetLength(Result, L);
  SetLength(TPA, L);
  for i := 0 to L - 1 do
    TPA[i] := Point(Arr[i].Tile.x, Arr[i].Tile.y);
  SortTPAFrom(TPA, Point(From.x, From.y));
  for i := 0 to L - 1 do
    for ii := 0 to L - 1 do
      if (TPA[i].x = Arr[i].Tile.x) and (TPA[i].y = Arr[i].Tile.y) then
        Result[i] := Arr[ii];
end;

function GetClosestNPCByIDEx(const IDs: TIntegerArray): TNPC;
var
  NPCArray, OurNPCs: TNPCArray;
  i, l, C, ii, ll: Integer;
begin
  Result := NULL_NPC;
  NPCArray := GetNPCs;
  l := Length(NPCArray);
  ll := Length(IDs);
  SetLength(OurNPCs, l);
  for i := 0 to l - 1 do
    for ii := 0 to ll - 1 do
      if (NPCArray[i].ID = IDs[ii]) then
      begin
        OurNPCs[C] := NPCArray[i];
        Inc(C);
        Break;
      end;
  SetLength(OurNPCs, C);
  OurNPCs := SortNPCs(OurNPCs, GetLocation);
  if (Length(OurNPCs) > 0) then
    Result := OurNPCs[0];
end;

function GetClosestNPCByID(const ID: Integer): TNPC;
begin
  Result := GetClosestNPCByIDEx([ID]);
end;