{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
RRL - Reflection Resource Library
Menu routines.

---------------------------------------------------------

 * function r_IsInterfaceValid(const id: Integer): Boolean;
     By: Timer
 * function r_GetInterface(const ParentID, ChildID: Integer): LongInt;
     By: Timer
 * function r_GetInterfaceTextEx(const PathToInterface: LongInt; Free: Boolean): string;
     By: Timer
 * function r_GetInterfaceText(const ParentID, ChildID: Integer): string;
     By: Timer
 * function r_GetInterfaceBox(const Offset: TPoint; const ParentID, ChildID: Integer): TBox;
     By: Timer
 * function r_IsClickContinue: Boolean;
     By: Timer
 * function r_ClickContinue: Boolean;
     By: Timer
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{
This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

Copyright (C) 2010 - 2011 by Joe Haddad, all rights reserved.
This file is part of the RRL project (https://github.com/Timer/RRL).

For extended permissions please contact me by E-Mail, Timer150@Gmail.com.
}

function r_IsInterfaceValid(const id: Integer): Boolean;
begin
  Result := _InvokeBooleanArray(0, r_Hooks[hook_Valid_Interfaces], id);
end;

function r_GetInterface(const ParentID, ChildID: Integer): LongInt;
begin
  Result := _Invoke2DObjectArray(0, r_Hooks[hook_Interfaces], ParentID, ChildID);
end;

function r_GetInterfaceTextEx(const PathToInterface: LongInt; Free: Boolean): string;
var
  Text: LongInt;
begin
  Text := _InvokeObject(PathToInterface, r_Hooks[hook_Interface_Text]);
  Result := r_GetString(Text);
  _FreeObject(Text);
  if (Free) then
    _FreeObject(PathToInterface);
end;

function r_GetInterfaceText(const ParentID, ChildID: Integer): string;
var
  PathToInterface: LongInt;
begin
  PathToInterface := r_GetInterface(ParentID, ChildID);
  Result := r_GetInterfaceTextEx(PathToInterface, True);
end;

function r_GetInterfaceBox(const Offset: TPoint; const ParentID, ChildID: Integer): TBox;
var
  PathToInterface: LongInt;
  x, y: Integer;
begin
  PathToInterface := r_GetInterface(ParentID, ChildID);
  x := _InvokeInteger(PathToInterface, r_Hooks[hook_InterfaceX]);
  y := _InvokeInteger(PathToInterface, r_Hooks[hook_InterfaceY]);
  Result := IntToBox(Offset.x + x, Offset.y + y,
                     Offset.x + x + _InvokeInteger(PathToInterface, r_Hooks[hook_InterfaceW]),
                     Offset.y + y + _InvokeInteger(PathToInterface, r_Hooks[hook_InterfaceH]));
  _FreeObject(PathToInterface);
end;

function r_IsClickContinue: Boolean;
var
  CheckInterfaces: TIntegerArray;
  i, ii, CC: Integer;
  PathToCheck: LongInt;
begin
  CheckInterfaces := [211, 241, 251, 101, 242, 102, 161, 249, 243, 64, 65, 244,
                      255, 249, 230, 372, 421, 66, 64, 236, 228];
  for i := 0 to High(CheckInterfaces) do
  begin
    PathToCheck := _InvokeObjectArray(0, r_Hooks[hook_Interfaces], CheckInterfaces[i]);
    CC := _InvokeArraySize(PathToCheck, '', 1);
    _FreeObject(PathToCheck);
    for ii := 0 to CC - 1 do
      if (Pos('lick here to cont', Lowercase(r_GetInterfaceText(CheckInterfaces[i], ii))) > 0) then
      begin
        Result := True;
        Exit;
      end;
  end;
end;

function r_ClickContinue: Boolean;
var
  CheckInterfaces: TIntegerArray;
  i, ii, CC: Integer;
  Box: TBox;
  PathToCheck: LongInt;
begin
  CheckInterfaces := [211, 241, 251, 101, 242, 102, 161, 249, 243, 64, 65, 244,
                      255, 249, 230, 372, 421, 66, 64, 236, 228];
  for i := 0 to High(CheckInterfaces) do
  begin
    PathToCheck := _InvokeObjectArray(0, r_Hooks[hook_Interfaces], CheckInterfaces[i]);
    CC := _InvokeArraySize(PathToCheck, '', 1);
    _FreeObject(PathToCheck);
    for ii := 0 to CC - 1 do
      if (Pos('lick here to cont', Lowercase(r_GetInterfaceText(CheckInterfaces[i], ii))) > 0) then
      begin
        Box := r_GetInterfaceBox(Point(7, 347), CheckInterfaces[i], ii);
        r_ClickMouseBox(Box.x1, Box.y1, Box.x2, Box.y2, True);
        Wait(RandomRange(500, 800));
        Result := True;
        Exit;
      end;
  end;
end;